<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astra</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://astrapub.github.io/"/>
  <updated>2020-02-25T04:07:58.232Z</updated>
  <id>http://astrapub.github.io/</id>
  
  <author>
    <name>Astra</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04. 数据结构与算法入门 | 排序算法</title>
    <link href="http://astrapub.github.io/2020/02/24/alg-04/"/>
    <id>http://astrapub.github.io/2020/02/24/alg-04/</id>
    <published>2020-02-24T14:49:04.000Z</published>
    <updated>2020-02-25T04:07:58.232Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>03. 数据结构与算法入门 | 递归</title>
    <link href="http://astrapub.github.io/2020/02/24/alg-03/"/>
    <id>http://astrapub.github.io/2020/02/24/alg-03/</id>
    <published>2020-02-24T14:49:03.000Z</published>
    <updated>2020-02-25T04:07:09.364Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://astrapub.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>02. 数据结构与算法入门 | 一篇文章讲清数组、链表、栈、队列</title>
    <link href="http://astrapub.github.io/2020/02/24/alg-02/"/>
    <id>http://astrapub.github.io/2020/02/24/alg-02/</id>
    <published>2020-02-24T14:49:02.000Z</published>
    <updated>2020-02-25T04:07:09.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://astrapub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://astrapub.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="链表" scheme="http://astrapub.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="栈" scheme="http://astrapub.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://astrapub.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>01. 数据结构与算法入门 | 什么是复杂度分析</title>
    <link href="http://astrapub.github.io/2020/02/24/alg-01/"/>
    <id>http://astrapub.github.io/2020/02/24/alg-01/</id>
    <published>2020-02-24T14:49:01.000Z</published>
    <updated>2020-02-25T04:07:09.372Z</updated>
    
    <content type="html"><![CDATA[<p>复杂度分析分为时间复杂度分析和空间复杂度分析，时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p><h3 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h3><ol><li>数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。</li><li>因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</li><li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。</li><li>复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</li></ol><h3 id="为什么使用复杂度分析？"><a href="#为什么使用复杂度分析？" class="headerlink" title="为什么使用复杂度分析？"></a>为什么使用复杂度分析？</h3><ol><li>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。</li><li>掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</li></ol><h3 id="如何进行复杂度分析？"><a href="#如何进行复杂度分析？" class="headerlink" title="如何进行复杂度分析？"></a>如何进行复杂度分析？</h3><ol><li>大O表示法<br> 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br> 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。<br> 空间复杂度分析比时间复杂度分析要简单很多，我们常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</li><li>复杂度分析法则<ul><li>单段代码看高频：比如循环。</li><li>多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</li><li>嵌套代码求乘积：比如递归、多重循环等</li><li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</li></ul></li></ol><h3 id="常用的复杂度级别"><a href="#常用的复杂度级别" class="headerlink" title="常用的复杂度级别"></a>常用的复杂度级别</h3><p><strong>多项式阶：</strong><br>随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）  </p><p><strong>非多项式阶：</strong><br>随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）</p><h3 id="复杂度分析的4个概念"><a href="#复杂度分析的4个概念" class="headerlink" title="复杂度分析的4个概念"></a>复杂度分析的4个概念</h3><ol><li>最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。</li><li>最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。</li><li>平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。</li><li>均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li></ol><h3 id="为什么要引入这4个概念？"><a href="#为什么要引入这4个概念？" class="headerlink" title="为什么要引入这4个概念？"></a>为什么要引入这4个概念？</h3><ol><li>同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。</li><li>代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</li></ol><h3 id="如何分析平均、均摊时间复杂度？"><a href="#如何分析平均、均摊时间复杂度？" class="headerlink" title="如何分析平均、均摊时间复杂度？"></a>如何分析平均、均摊时间复杂度？</h3><ol><li>平均时间复杂度<br> 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</li><li>均摊时间复杂度<br> 两个条件满足时使用：  <ul><li>代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；</li><li>低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复杂度分析分为时间复杂度分析和空间复杂度分析，时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="算法" scheme="http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="复杂度分析" scheme="http://astrapub.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>00. 数据结构与算法入门 | 开篇，如何学习</title>
    <link href="http://astrapub.github.io/2020/02/24/alg-00/"/>
    <id>http://astrapub.github.io/2020/02/24/alg-00/</id>
    <published>2020-02-24T14:49:00.000Z</published>
    <updated>2020-02-25T04:07:09.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是数据结构，什么是算法"><a href="#什么是数据结构，什么是算法" class="headerlink" title="什么是数据结构，什么是算法"></a>什么是数据结构，什么是算法</h3><p>大部分教材里开篇都会有相关的定义，但是这些定义都很抽象，而且对于我们理解没有什么实质性帮助，所以我们不必死扣定义。那么来讲讲我的理解，数据结构就是指一组数据的存储结构，算法就是操作数据的一组方法。</p><p>可以以图书馆为例，为了方便查找，图书管理员把图书会按照一定规律放到书架上，这就是书籍这种“数据”的存储结构，而怎么才能查到一本书的具体位置，方法有很多，可以一本一本的找，也可以将图书分类然后再查找，这个查找的方法就是算法。</p><p>所以，数据结构和算法是相辅相成的，<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。</p><h3 id="学习数据结构与算法的重要性"><a href="#学习数据结构与算法的重要性" class="headerlink" title="学习数据结构与算法的重要性"></a>学习数据结构与算法的重要性</h3><ol><li>直接好处是能够有写出性能更优的代码。</li><li>算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面。</li><li>长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。</li></ol><h3 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h3><p><img src="/.io//%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.jpg" alt="数据结构与算法知识体系"></p><h3 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h3><p>数据结构与算法学习，其实是一个很枯燥的过程，很容易就坚持不下来，其实可以使用学习技巧来提升学习体验：</p><ol><li>边学边练，适度刷题；</li><li>多问、多思考、多互动，最好能和志同道合的朋友一起学习；</li><li>给自己设立一个切实可行的目标，就像打怪升级，坚持下来；</li><li>反复迭代、温故知新，不断沉淀。</li></ol><h3 id="学习的方法论"><a href="#学习的方法论" class="headerlink" title="学习的方法论"></a>学习的方法论</h3><p>首先我认为学习分两点，第一，知识点的学习，主要是记忆和理解，相对简单，有清晰的目标，有良好的正反馈，学会了就是会了，可以拿来炫耀。比如，我可以告诉你帆船是通过走之字型逆风航行的，相信你很容易就能明白并记住这个知识点，但是你就能因此学会了如何驾驶帆船么，并不能，那么久引出了下面的内容；第二，技能的学习，这就需要刻意练习，不断纠正自己的错误，标准不清晰也就不容易量化，不容易形成正反馈，也就容易放弃。最典型的就是学习英语，需要反复练习，编程亦然，需要练习。</p><p>所以我总结以下几点关于学习的方法，希望和大家一起交流：</p><ol><li>首先提高知识的广度，建立知识体系，再去拓展知识的深度；</li><li>制定切实可行的目标，一步一步来；</li><li>建立正反馈系统，可以跟牛人学，也可以和朋友一起学，对于错误能及时发现、及时纠正；</li><li>持续输出，可以写学习笔记、总结，也可以是代码和注释，如果能教会别人效果更佳；</li><li>坚持学习和健身，健身能够增加多巴胺的分泌，能使人身心愉悦，同时能提升延迟满足的能力，提高学习效率。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是数据结构，什么是算法&quot;&gt;&lt;a href=&quot;#什么是数据结构，什么是算法&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构，什么是算法&quot;&gt;&lt;/a&gt;什么是数据结构，什么是算法&lt;/h3&gt;&lt;p&gt;大部分教材里开篇都会有相关的定义，但是这些定义都很抽
      
    
    </summary>
    
    
      <category term="算法" scheme="http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://astrapub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://astrapub.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="链表" scheme="http://astrapub.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="栈" scheme="http://astrapub.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://astrapub.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法入门——排序算法</title>
    <link href="http://astrapub.github.io/2020/01/14/alg-order/"/>
    <id>http://astrapub.github.io/2020/01/14/alg-order/</id>
    <published>2020-01-14T06:30:40.000Z</published>
    <updated>2020-01-17T08:14:43.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>如果有一组数，按从大到小排列，遍历列表，找出最大的数并添加到一个新列表，再次这样做，找出第二大的数，以此类推，这样便可得到一个有序列表。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最大元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargest</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> largest = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> largestIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; largest) &#123;</span><br><span class="line">            largest = arr[i];</span><br><span class="line">            largestIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> largestIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组进行排序 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">let</span> newArr = []</span><br><span class="line">    <span class="keyword">while</span>(arr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> largest = findLargest(arr);</span><br><span class="line">        newArr.push(arr.splice(largest, <span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(selectionSort([<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>]));</span><br></pre></td></tr></table></figure><p>选择排序需要的总时间为 O(n × n)，即O(n2)。</p><blockquote><p><strong>需要检查的元素数越来越少</strong></p><p>随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一 个。既然如此，运行时间怎么还是O(n2)呢?这个问题问得好，这与大O表示法中的常数相关，后面有机会我还详细解释一下。</p><p>没错，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素 数依次为n - 1, n - 2, …, 2和1。平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。 但大O表示法省略诸如1/2这样的常数，因此简单地写 作O(n × n)或O(n2)。</p></blockquote><p>选择排序是一种灵巧的算法，但其速度不是很快。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h4 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h4><p>在介绍快速排序之前先介绍一下“分而治之”（divide and conquer，D&amp;C），一种著名的递归问题解决方法。<br>使用D&amp;C解决问题的过程包括两个步骤：  </p><ul><li>找出基线条件，这种条件必须尽可能简单。</li><li>不断将问题分解(或者说缩小规模)，直到符合基线条件。</li></ul><p>D&amp;C 的工作原理：</p><ul><li>找出简单的基线条件。</li><li>确定如何缩小问题的规模，使其符合基线条件。</li></ul><p>D&amp;C 并非可用于解决问题的算法，而是一种解决问题的思路。</p><h4 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是一种常用的排序算法，比选择排序快得多。例如，C 语言标准库中的函数 qsort 实现的就是快速排序。快速排序也使用了 D&amp;C。<br>首先根据 D&amp;C 的步骤，我们需要找到基线条件：数组为空或只包含一个元素。在这种情况下，只需原样返回数组——根本就不用排序。然后缩小问题：分解数组，直到满足基线条件。从数组中选一个元素，作为基准值（pivot）。<br>接下来，找出比基准值小的元素以及比基准值大的元素，这个过程被称为分区（partitioning），会得到：</p><ul><li>一个由所有小于基准值的数字组成的子数组</li><li>基准值</li><li>一个由所有大于基准值的数组组成的子数组  </li></ul><p>我们将得到的两个子数组再进行上述操作，直到都满足基线条件。这样我们便得到一个有序列表。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quicksort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归条件</span></span><br><span class="line">        <span class="keyword">let</span> pivot = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> less = [];</span><br><span class="line">        <span class="keyword">let</span> greater = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivot)&#123;</span><br><span class="line">                less.push(arr[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot)&#123;</span><br><span class="line">                greater.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> [...quicksort(less), pivot, ...quicksort(greater) ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quicksort([<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>]));</span><br></pre></td></tr></table></figure><p>分解数组的过程使用了归纳证明的思想，如果是两个元素的数组我们可以轻易对其排序，那如果是三个元素呢，我们可以将其拆分为两个元素的数组，和一个元素的数组，以此类推我们可以对任意长度数组进行拆分，那么我们可以任意长度数组排序。</p><blockquote><p><strong>归纳证明</strong>  </p><p>归纳证明是一种证明算法行之有效的方式，它分两步:基线 条件和归纳条件。是不是有点似曾相识的感觉?例如，假设我要证明我能爬到梯子的最上面。 递归条件是这样的:如果我站在一个横档上，就能将脚放到下一个横档上。换言之，如果我站 在第二个横档上，就能爬到第三个横档。这就是归纳条件。而基线条件是这样的，即我已经站 在第一个横档上。因此，通过每次爬一个横档，我就能爬到梯子最顶端。</p><p>对于快速排序，可使用类似的推理。在基线条件中，我证明这种算法对空数组或包含一个 元素的数组管用。在归纳条件中，我证明如果快速排序对包含一个元素的数组管用，对包含两 个元素的数组也将管用;如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用， 以此类推。因此，我可以说，快速排序对任何长度的数组都管用。这里不再深入讨论归纳证明， 但它很有趣，并与D&amp;C协同发挥作用。</p></blockquote><p>快速排序的速度取决于选择的基准值，在最糟情况下，其运行时间为O(n2)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;p&gt;如果有一组数，按从大到小排列，遍历列表，找出最大的数并添加到一个新列表，再次这样做，找出第二大的数，以此类推，这样便可得到一
      
    
    </summary>
    
    
      <category term="算法" scheme="http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Promise、Async/Await 备忘</title>
    <link href="http://astrapub.github.io/2020/01/06/js-promise/"/>
    <id>http://astrapub.github.io/2020/01/06/js-promise/</id>
    <published>2020-01-06T07:17:56.000Z</published>
    <updated>2020-01-07T06:19:55.568Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><p>Promise 可以理解为一个容器，保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>有all、reject、resolve 这几个方法，原型上有then、catch等方法。  </p><p><strong>有以下特点：</strong></p><ul><li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。  </p></li></ul><h2 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h2><p>其中<code>setTimeout</code>的回调函数放到宏任务队列里，等到执行栈清空以后执行； <code>promise.then</code>里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；<code>async</code>函数表示函数里面可能会有异步方法，<code>await</code>后面跟一个表达式，<code>async</code>方法执行时，遇到<code>await</code>会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</p><p>也就是说执行顺序是：任务栈（包括<code>await</code><strong>后</strong>面的表达式）&gt; 微任务队列（<code>promise.then</code>回调，<code>await</code><strong>下</strong>面的表达式）&gt; 宏任务队列（<code>setTimeout</code>回调）。</p><h2 id="多个异步任务"><a href="#多个异步任务" class="headerlink" title="多个异步任务"></a>多个异步任务</h2><p>Promise 还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。  </p><p>要串行执行这样的异步任务，不用 Promise 需要写一层一层的嵌套代码。有了 Promise，我们只需要简单地写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job1.then(job2).then(job3).catch(handleError);</span><br></pre></td></tr></table></figure><p>其中，<code>job1</code>、<code>job2</code>和<code>job3</code>都是 Promise 对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/7c6e4d21bf77" target="_blank" rel="noopener">https://www.jianshu.com/p/7c6e4d21bf77</a><br><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7</a><br><a href="https://segmentfault.com/a/1190000011296839" target="_blank" rel="noopener">async/await 执行顺序详解</a><br><a href="https://www.jianshu.com/p/b4f0425b22a1" target="_blank" rel="noopener">Promise原理与实现</a><br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 入门之 Promise 对象</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。&lt;/p&gt;
&lt;p&gt;Promise 可以理解为一个容器，保存着某个未来才会结束的事件（通
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://astrapub.github.io/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://astrapub.github.io/tags/js/"/>
    
      <category term="Promise" scheme="http://astrapub.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>深刻理解 Javascript 的 this 指向</title>
    <link href="http://astrapub.github.io/2020/01/05/js-this/"/>
    <id>http://astrapub.github.io/2020/01/05/js-this/</id>
    <published>2020-01-05T14:52:35.000Z</published>
    <updated>2020-01-06T03:18:18.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>首先我们来看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.a) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = obj.foo;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">obj.foo()</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>写法一和写法二的执行结果分别是：1、2。之所以运行结果不用，是因为方法中使用了 this 关键字。this 指代方法调用者，即运行时的环境。对于obj.foo()，foo 运行在 obj 中，所以 this 指向 obj。而 foo()，foo 运行在全局，所以 this 指向全局。<br>由此得出结论：</p><ul><li>普通函数的 this 总是指向它的直接调用者。</li><li>在严格模式下，没找到直接调用者，则函数中的 this 是 undefined。</li><li>在默认模式下（非严格模式），没找到直接调用者，则函数中的 this 指向 window。</li></ul><h2 id="this-的由来"><a href="#this-的由来" class="headerlink" title="this 的由来"></a>this 的由来</h2><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p><h4 id="内存数据结果"><a href="#内存数据结果" class="headerlink" title="内存数据结果"></a>内存数据结果</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>:  <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>上面的代码将一个对象赋值给变量<code>obj</code>。Javascript 引擎会先在内存里面，生成一个对象<code>{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。<br>也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。<br>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span></span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，foo属性的值保存在属性描述对象的value属性里面。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">f</span>: f &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f()</span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>Javascript 允许在函数体内部，引用当前环境的其他变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，函数体里面使用了变量x。该变量由运行环境提供。<br>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>。<br><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061804.png" alt="avatar"><br>在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。<br><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061805.png" alt="avatar"><br>回到本文开头提出的问题，<code>obj.foo()</code>是通过<code>obj</code>找到<code>foo</code>，所以就是在<code>obj</code>环境执行。一旦<code>var foo = obj.foo</code>，变量<code>foo</code>就直接指向函数本身，所以<code>foo()</code>就变成在全局环境执行。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在 ES6 中新增的箭头函数，不仅简化了代码，还解决 this 飘忽不定的指向问题。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a : <span class="number">1</span>,</span><br><span class="line">    foo : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.a),<span class="number">3000</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>此代码运行结果为 undefined，this 的指向是全局的 window 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()=&gt;&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;</span><br></pre></td></tr></table></figure><p>其中()内是要带入的参数，{}内是要执行的语句。箭头函数是函数式编程的一种体现，函数式编程将更多的关注点放在输入和输出的关系，省去了过程的一些因素，因此箭头函数中没有自己的 this，arguments，new target（ES6）和 super(ES6)。箭头函数相当于匿名函数，因此不能使用new来作为构造函数使用。<br>箭头函数中的 this 始终指向其父级作用域中的 this 。换句话说，箭头函数会捕获其所在的上下文的 this 值，作为自己的 this 值。任何方法都改变不了其指向，如 call(), bind(), apply()。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用，它与调用时的上下文无关。我们用代码来解释一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>阮一峰的 <a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">《JavaScript 的 this 原理》</a></li><li><a href="https://www.jianshu.com/p/e5fe25edd78a" target="_blank" rel="noopener">《ES6箭头函数与普通函数的区别》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;首先我们来看一段代码&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://astrapub.github.io/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://astrapub.github.io/tags/js/"/>
    
      <category term="this" scheme="http://astrapub.github.io/tags/this/"/>
    
      <category term="箭头函数" scheme="http://astrapub.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019回顾，2020展望</title>
    <link href="http://astrapub.github.io/2020/01/04/review2019/"/>
    <id>http://astrapub.github.io/2020/01/04/review2019/</id>
    <published>2020-01-04T14:12:17.000Z</published>
    <updated>2020-01-05T12:41:49.679Z</updated>
    
    <content type="html"><![CDATA[<p>进入 2020 年已经4个日子了，每次跨年觉得应该有仪式感。当跨年的那一刻，2019像电影一样在脑海过了一遍，不禁要问2019都干了什么。从毕业到现在从事开发工作已经整整5个年头，有感动也有遗憾，5年的时间想想如果能坚持做一件事想想现在应该也小有成就了。</p><p>2019其实是寻找的一年，寻找自己，寻找答案。我不知道答案是否找到了，但确实明白了一些事，不再幻想，不再漫不经心，不再天马星空。越来越明白踏实做事的重要性，不再轻易被情绪控制，不卑不亢。明白世界运行的规律，独立思考，不被洗脑。</p><p>2019也是不破不立的一年，这一年经历了很多，跌宕起伏。值得庆幸的是这一年我跳出了自己的舒适圈，直面自己的弱点，虽然过程会有痛苦，但成长的喜悦难以言表，有些困难过去了就真的过去了。</p><p>目标重要，如何实现目标更重要，还是要有计划，有些看似困难的问题，其实都是有解的，掌握方式方法，刻意去练习，进步会很快。</p><p>2020，持续做好要做的事，丰富自己的知识体系，建立个人品牌，将博客继续写下去，持续写作，如果条件允许出系列教程。</p><p>review 系列也要继续写下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进入 2020 年已经4个日子了，每次跨年觉得应该有仪式感。当跨年的那一刻，2019像电影一样在脑海过了一遍，不禁要问2019都干了什么。从毕业到现在从事开发工作已经整整5个年头，有感动也有遗憾，5年的时间想想如果能坚持做一件事想想现在应该也小有成就了。&lt;/p&gt;
&lt;p&gt;20
      
    
    </summary>
    
    
      <category term="回顾" scheme="http://astrapub.github.io/categories/%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="回顾" scheme="http://astrapub.github.io/tags/%E5%9B%9E%E9%A1%BE/"/>
    
      <category term="总结" scheme="http://astrapub.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2019" scheme="http://astrapub.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 使用教程</title>
    <link href="http://astrapub.github.io/2020/01/03/hexo-course/"/>
    <id>http://astrapub.github.io/2020/01/03/hexo-course/</id>
    <published>2020-01-03T09:16:49.000Z</published>
    <updated>2020-01-04T08:18:57.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要安装 node.js，node.js 安装教程可参看 <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a><br>然后执行<code>npm install -g hexo</code> 或 <code>yarn global add hexo</code> 安装 Hexo。</p><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm i 或 yarn install</span><br></pre></td></tr></table></figure><p>目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>在执行 hexo init 的时候可能git会报错，可以到 <a href="https://github.com/hexojs/hexo-starter.git" target="_blank" rel="noopener">https://github.com/hexojs/hexo-starter.git</a> 这个地址直接把 Hexo 项目下载下来，然后改成自己项目名字。  </p><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 scaffold/post.md 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</p><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的配置信息，可以<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a>网站名称、关键字、语言、作者、时区等信息。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题文件夹。可以去 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 寻找喜欢的主题。  </p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>我使用的主题是 <a href="https://blog.cofess.com" target="_blank" rel="noopener">pure</a> </p><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>在你的 hexo 项目文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;cofess&#x2F;hexo-theme-pure.git themes&#x2F;pure</span><br></pre></td></tr></table></figure><p>修改配置文件 <code>hexo/_config.yml</code> 中 <code>theme</code> 为 <code>pure</code>。</p><h3 id="gitalk-评论"><a href="#gitalk-评论" class="headerlink" title="gitalk 评论"></a>gitalk 评论</h3><p>Gitalk 是一个基于 Github Issue 的评论插件，每增加一条评论相应的在 GitHub 项目增加一条 Issue。 </p><h4 id="注册-GitHub-Application"><a href="#注册-GitHub-Application" class="headerlink" title="注册 GitHub Application"></a>注册 GitHub Application</h4><p>到 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a> 注册 GitHub Application<br>填写 Application name（项目名称），Homepage URL（博客链接），Application description（描述），authorization callback URL（回调地址，博客链接）等信息，完成注册，获取到 Client ID 和 Client Secret。<br>如果项目在 Organization 下，需要进入到相应的 Organization，点击 Settings &gt; OAuth Apps，注册 GitHub Application。</p><h4 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 _config.yml</h4><p>配置文件位置 themes/pure/_config.yml。<br>修改 comment &gt; type 为：gitalk，将 Client ID 和 Client Secret 填写的相应位置，并填写 owner，admin，repo。owner 为项目所有者，如果是 Organization，这填写 Organization 名称。admin 为你的用户名，repo 对应 GitHub 中的项目名。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h5 id="创建一个新网站"><a href="#创建一个新网站" class="headerlink" title="创建一个新网站"></a>创建一个新网站</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure><h5 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout 可选，如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, –path</td><td>自定义新文章的路径</td></tr><tr><td>-r, –replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, –slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure><h5 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate 或 g</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr></tbody></table><p><strong>示例</strong><br>检测文件变动实时预览：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -w</span><br></pre></td></tr></table></figure><p>生成文件自动部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><h5 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server 或 s</span><br></pre></td></tr></table></figure><p>默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>部署方式请看 <a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/one-command-deployment</a></p><h5 id="清除缓存文件"><a href="#清除缓存文件" class="headerlink" title="清除缓存文件"></a>清除缓存文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;首先需要安装 node.js，node.js 安装教程可参看 &lt;a href=&quot;https://www.runoob.com/nodejs/
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://astrapub.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://astrapub.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>计划</title>
    <link href="http://astrapub.github.io/2020/01/02/plan/"/>
    <id>http://astrapub.github.io/2020/01/02/plan/</id>
    <published>2020-01-02T05:53:24.000Z</published>
    <updated>2020-01-02T05:53:24.166Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
