{"meta":{"title":"Astra","subtitle":"","description":"Astra 个人博客","author":"Astra","url":"http://astrapub.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-01-02T06:08:50.375Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"/404.html","permalink":"http://astrapub.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-01-02T06:31:19.074Z","updated":"2020-01-02T06:31:19.073Z","comments":false,"path":"about/index.html","permalink":"http://astrapub.github.io/about/index.html","excerpt":"","text":"名字: Astra年龄: 29性别: 男职业: 软件工程师经验: 5年地址: 北京学历: 本科github: https://github.com/atove"},{"title":"书单","date":"2020-01-02T06:08:50.405Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"books/index.html","permalink":"http://astrapub.github.io/books/index.html","excerpt":"","text":""},{"title":"About me","date":"2019-12-28T03:18:52.000Z","updated":"2019-12-28T03:39:16.509Z","comments":true,"path":"about/me.html","permalink":"http://astrapub.github.io/about/me.html","excerpt":"","text":"hex"},{"title":"分类","date":"2020-01-02T06:08:50.421Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"categories/index.html","permalink":"http://astrapub.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-01-02T06:08:50.457Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"repository/index.html","permalink":"http://astrapub.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-02T06:08:50.473Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://astrapub.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-01-02T06:08:50.439Z","updated":"2019-12-30T06:26:53.000Z","comments":true,"path":"links/index.html","permalink":"http://astrapub.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"算法入门——排序算法","slug":"alg-order","date":"2020-01-14T06:30:40.000Z","updated":"2020-01-17T08:14:43.425Z","comments":true,"path":"2020/01/14/alg-order/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-order/","excerpt":"","text":"选择排序如果有一组数，按从大到小排列，遍历列表，找出最大的数并添加到一个新列表，再次这样做，找出第二大的数，以此类推，这样便可得到一个有序列表。 示例1234567891011121314151617181920212223// 找出最大元素function findLargest(arr)&#123; let largest = arr[0]; let largestIndex = 0; for (let i in arr)&#123; if (arr[i] &gt; largest) &#123; largest = arr[i]; largestIndex = i; &#125; &#125; return largestIndex;&#125;// 对数组进行排序 function selectionSort(arr)&#123; let newArr = [] while(arr.length &gt; 0)&#123; let largest = findLargest(arr); newArr.push(arr.splice(largest, 1)[0]) &#125; return newArr&#125;console.log(selectionSort([5, 3, 6, 2, 10])); 选择排序需要的总时间为 O(n × n)，即O(n2)。 需要检查的元素数越来越少 随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一 个。既然如此，运行时间怎么还是O(n2)呢?这个问题问得好，这与大O表示法中的常数相关，后面有机会我还详细解释一下。 没错，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素 数依次为n - 1, n - 2, …, 2和1。平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。 但大O表示法省略诸如1/2这样的常数，因此简单地写 作O(n × n)或O(n2)。 选择排序是一种灵巧的算法，但其速度不是很快。 快速排序分而治之在介绍快速排序之前先介绍一下“分而治之”（divide and conquer，D&amp;C），一种著名的递归问题解决方法。使用D&amp;C解决问题的过程包括两个步骤： 找出基线条件，这种条件必须尽可能简单。 不断将问题分解(或者说缩小规模)，直到符合基线条件。 D&amp;C 的工作原理： 找出简单的基线条件。 确定如何缩小问题的规模，使其符合基线条件。 D&amp;C 并非可用于解决问题的算法，而是一种解决问题的思路。 快速排序快速排序是一种常用的排序算法，比选择排序快得多。例如，C 语言标准库中的函数 qsort 实现的就是快速排序。快速排序也使用了 D&amp;C。首先根据 D&amp;C 的步骤，我们需要找到基线条件：数组为空或只包含一个元素。在这种情况下，只需原样返回数组——根本就不用排序。然后缩小问题：分解数组，直到满足基线条件。从数组中选一个元素，作为基准值（pivot）。接下来，找出比基准值小的元素以及比基准值大的元素，这个过程被称为分区（partitioning），会得到： 一个由所有小于基准值的数字组成的子数组 基准值 一个由所有大于基准值的数组组成的子数组 我们将得到的两个子数组再进行上述操作，直到都满足基线条件。这样我们便得到一个有序列表。 12345678910111213141516171819function quicksort(arr) &#123; if (arr.length &lt; 2)&#123; return arr &#125; else &#123; // 递归条件 let pivot = arr[0]; let less = []; let greater = []; for (let i in arr)&#123; if (arr[i] &lt; pivot)&#123; less.push(arr[i]) &#125; else if (arr[i] &gt; pivot)&#123; greater.push(arr[i]) &#125; &#125; return [...quicksort(less), pivot, ...quicksort(greater) ] &#125;&#125;console.log(quicksort([5, 3, 6, 2, 10])); 分解数组的过程使用了归纳证明的思想，如果是两个元素的数组我们可以轻易对其排序，那如果是三个元素呢，我们可以将其拆分为两个元素的数组，和一个元素的数组，以此类推我们可以对任意长度数组进行拆分，那么我们可以任意长度数组排序。 归纳证明 归纳证明是一种证明算法行之有效的方式，它分两步:基线 条件和归纳条件。是不是有点似曾相识的感觉?例如，假设我要证明我能爬到梯子的最上面。 递归条件是这样的:如果我站在一个横档上，就能将脚放到下一个横档上。换言之，如果我站 在第二个横档上，就能爬到第三个横档。这就是归纳条件。而基线条件是这样的，即我已经站 在第一个横档上。因此，通过每次爬一个横档，我就能爬到梯子最顶端。 对于快速排序，可使用类似的推理。在基线条件中，我证明这种算法对空数组或包含一个 元素的数组管用。在归纳条件中，我证明如果快速排序对包含一个元素的数组管用，对包含两 个元素的数组也将管用;如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用， 以此类推。因此，我可以说，快速排序对任何长度的数组都管用。这里不再深入讨论归纳证明， 但它很有趣，并与D&amp;C协同发挥作用。 快速排序的速度取决于选择的基准值，在最糟情况下，其运行时间为O(n2)。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"Promise、Async/Await 备忘","slug":"js-promise","date":"2020-01-06T07:17:56.000Z","updated":"2020-01-07T06:19:55.568Z","comments":true,"path":"2020/01/06/js-promise/","link":"","permalink":"http://astrapub.github.io/2020/01/06/js-promise/","excerpt":"","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise 可以理解为一个容器，保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 有all、reject、resolve 这几个方法，原型上有then、catch等方法。 有以下特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 setTimeout、Promise、Async/Await 的区别其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行； promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。 也就是说执行顺序是：任务栈（包括await后面的表达式）&gt; 微任务队列（promise.then回调，await下面的表达式）&gt; 宏任务队列（setTimeout回调）。 多个异步任务Promise 还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用 Promise 需要写一层一层的嵌套代码。有了 Promise，我们只需要简单地写： 1job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是 Promise 对象。 参考https://www.jianshu.com/p/7c6e4d21bf77https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7async/await 执行顺序详解Promise原理与实现ES6 入门之 Promise 对象","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://astrapub.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://astrapub.github.io/tags/js/"},{"name":"Promise","slug":"Promise","permalink":"http://astrapub.github.io/tags/Promise/"}]},{"title":"深刻理解 Javascript 的 this 指向","slug":"js-this","date":"2020-01-05T14:52:35.000Z","updated":"2020-01-06T03:18:18.977Z","comments":true,"path":"2020/01/05/js-this/","link":"","permalink":"http://astrapub.github.io/2020/01/05/js-this/","excerpt":"","text":"现象首先我们来看一段代码 1234567891011let a = 2;let obj = &#123; a: 1, foo: function () &#123; console.log(this.a) &#125;&#125;;let foo = obj.foo;// 写法一obj.foo()// 写法二foo() 写法一和写法二的执行结果分别是：1、2。之所以运行结果不用，是因为方法中使用了 this 关键字。this 指代方法调用者，即运行时的环境。对于obj.foo()，foo 运行在 obj 中，所以 this 指向 obj。而 foo()，foo 运行在全局，所以 this 指向全局。由此得出结论： 普通函数的 this 总是指向它的直接调用者。 在严格模式下，没找到直接调用者，则函数中的 this 是 undefined。 在默认模式下（非严格模式），没找到直接调用者，则函数中的 this 指向 window。 this 的由来JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 内存数据结果1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。Javascript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 12345678&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125; 注意，foo属性的值保存在属性描述对象的value属性里面。 函数这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 123456&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125; 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() 环境变量Javascript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量x。该变量由运行环境提供。现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的this.x就是指当前运行环境的x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x指向全局环境的x。在obj环境执行，this.x指向obj.x。回到本文开头提出的问题，obj.foo()是通过obj找到foo，所以就是在obj环境执行。一旦var foo = obj.foo，变量foo就直接指向函数本身，所以foo()就变成在全局环境执行。 箭头函数在 ES6 中新增的箭头函数，不仅简化了代码，还解决 this 飘忽不定的指向问题。 12345678var obj = &#123; a : 1, foo : function()&#123; setTimeout( function()&#123;console.log(this.a),3000&#125;) &#125;&#125;obj.foo(); //undefined 此代码运行结果为 undefined，this 的指向是全局的 window 对象。 1()=&gt;&#123;console.log(this)&#125; 其中()内是要带入的参数，{}内是要执行的语句。箭头函数是函数式编程的一种体现，函数式编程将更多的关注点放在输入和输出的关系，省去了过程的一些因素，因此箭头函数中没有自己的 this，arguments，new target（ES6）和 super(ES6)。箭头函数相当于匿名函数，因此不能使用new来作为构造函数使用。箭头函数中的 this 始终指向其父级作用域中的 this 。换句话说，箭头函数会捕获其所在的上下文的 this 值，作为自己的 this 值。任何方法都改变不了其指向，如 call(), bind(), apply()。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用，它与调用时的上下文无关。我们用代码来解释一下。 参考 阮一峰的 《JavaScript 的 this 原理》 《ES6箭头函数与普通函数的区别》","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://astrapub.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://astrapub.github.io/tags/js/"},{"name":"this","slug":"this","permalink":"http://astrapub.github.io/tags/this/"},{"name":"箭头函数","slug":"箭头函数","permalink":"http://astrapub.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}]},{"title":"2019回顾，2020展望","slug":"review2019","date":"2020-01-04T14:12:17.000Z","updated":"2020-01-05T12:41:49.679Z","comments":true,"path":"2020/01/04/review2019/","link":"","permalink":"http://astrapub.github.io/2020/01/04/review2019/","excerpt":"","text":"进入 2020 年已经4个日子了，每次跨年觉得应该有仪式感。当跨年的那一刻，2019像电影一样在脑海过了一遍，不禁要问2019都干了什么。从毕业到现在从事开发工作已经整整5个年头，有感动也有遗憾，5年的时间想想如果能坚持做一件事想想现在应该也小有成就了。 2019其实是寻找的一年，寻找自己，寻找答案。我不知道答案是否找到了，但确实明白了一些事，不再幻想，不再漫不经心，不再天马星空。越来越明白踏实做事的重要性，不再轻易被情绪控制，不卑不亢。明白世界运行的规律，独立思考，不被洗脑。 2019也是不破不立的一年，这一年经历了很多，跌宕起伏。值得庆幸的是这一年我跳出了自己的舒适圈，直面自己的弱点，虽然过程会有痛苦，但成长的喜悦难以言表，有些困难过去了就真的过去了。 目标重要，如何实现目标更重要，还是要有计划，有些看似困难的问题，其实都是有解的，掌握方式方法，刻意去练习，进步会很快。 2020，持续做好要做的事，丰富自己的知识体系，建立个人品牌，将博客继续写下去，持续写作，如果条件允许出系列教程。 review 系列也要继续写下去。","categories":[{"name":"回顾","slug":"回顾","permalink":"http://astrapub.github.io/categories/%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"回顾","slug":"回顾","permalink":"http://astrapub.github.io/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"总结","slug":"总结","permalink":"http://astrapub.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"2019","slug":"2019","permalink":"http://astrapub.github.io/tags/2019/"}]},{"title":"Hexo 使用教程","slug":"hexo-course","date":"2020-01-03T09:16:49.000Z","updated":"2020-01-04T08:18:57.647Z","comments":true,"path":"2020/01/03/hexo-course/","link":"","permalink":"http://astrapub.github.io/2020/01/03/hexo-course/","excerpt":"","text":"安装首先需要安装 node.js，node.js 安装教程可参看 https://www.runoob.com/nodejs/nodejs-install-setup.html然后执行npm install -g hexo 或 yarn global add hexo 安装 Hexo。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm i 或 yarn install 目录结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 在执行 hexo init 的时候可能git会报错，可以到 https://github.com/hexojs/hexo-starter.git 这个地址直接把 Hexo 项目下载下来，然后改成自己项目名字。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 scaffold/post.md 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。 _config.yml网站的配置信息，可以配置网站名称、关键字、语言、作者、时区等信息。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题文件夹。可以去 https://hexo.io/themes/ 寻找喜欢的主题。 安装主题我使用的主题是 pure 启用主题在你的 hexo 项目文件夹下执行： 1git clone https:&#x2F;&#x2F;github.com&#x2F;cofess&#x2F;hexo-theme-pure.git themes&#x2F;pure 修改配置文件 hexo/_config.yml 中 theme 为 pure。 gitalk 评论Gitalk 是一个基于 Github Issue 的评论插件，每增加一条评论相应的在 GitHub 项目增加一条 Issue。 注册 GitHub Application到 https://github.com/settings/applications/new 注册 GitHub Application填写 Application name（项目名称），Homepage URL（博客链接），Application description（描述），authorization callback URL（回调地址，博客链接）等信息，完成注册，获取到 Client ID 和 Client Secret。如果项目在 Organization 下，需要进入到相应的 Organization，点击 Settings &gt; OAuth Apps，注册 GitHub Application。 配置 _config.yml配置文件位置 themes/pure/_config.yml。修改 comment &gt; type 为：gitalk，将 Client ID 和 Client Secret 填写的相应位置，并填写 owner，admin，repo。owner 为项目所有者，如果是 Organization，这填写 Organization 名称。admin 为你的用户名，repo 对应 GitHub 中的项目名。 常用命令创建一个新网站1hexo init [folder] 新建一篇文章1$ hexo new [layout] &lt;title&gt; layout 可选，如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。如： 1$ hexo new &quot;post title with whitespace&quot; 参数 描述 -p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about&#x2F;me &quot;About me&quot; 生成静态文件1$ hexo generate 或 g 参数 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 示例检测文件变动实时预览： 1$ hexo g -w 生成文件自动部署： 1$ hexo g -d 启动服务器1$ hexo server 或 s 默认情况下，访问网址为： http://localhost:4000/。 部署1$ hexo deploy 部署方式请看 https://hexo.io/zh-cn/docs/one-command-deployment 清除缓存文件1$ hexo clean","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://astrapub.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://astrapub.github.io/tags/Hexo/"}]},{"title":"计划","slug":"plan","date":"2020-01-02T05:53:24.000Z","updated":"2020-01-02T05:53:24.166Z","comments":true,"path":"2020/01/02/plan/","link":"","permalink":"http://astrapub.github.io/2020/01/02/plan/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-12-28T02:58:29.626Z","updated":"2019-12-28T02:58:29.626Z","comments":true,"path":"2019/12/28/hello-world/","link":"","permalink":"http://astrapub.github.io/2019/12/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}