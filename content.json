{"meta":{"title":"Astra","subtitle":"","description":"Astra 个人博客","author":"Astra","url":"http://astrapub.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-01-02T06:08:50.375Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"/404.html","permalink":"http://astrapub.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-25T07:29:46.242Z","updated":"2020-02-25T07:29:46.241Z","comments":false,"path":"about/index.html","permalink":"http://astrapub.github.io/about/index.html","excerpt":"","text":"名字: Astra年龄: 28性别: 男职业: 软件工程师经验: 6年地址: 北京学历: 本科github: https://github.com/atoveBlog: https://astrapub.github.io"},{"title":"书单","date":"2020-01-02T06:08:50.405Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"books/index.html","permalink":"http://astrapub.github.io/books/index.html","excerpt":"","text":""},{"title":"About me","date":"2019-12-28T03:18:52.000Z","updated":"2019-12-28T03:39:16.509Z","comments":true,"path":"about/me.html","permalink":"http://astrapub.github.io/about/me.html","excerpt":"","text":"hex"},{"title":"分类","date":"2020-01-02T06:08:50.421Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"categories/index.html","permalink":"http://astrapub.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-01-02T06:08:50.457Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"repository/index.html","permalink":"http://astrapub.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-02T06:08:50.473Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://astrapub.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-01-02T06:08:50.439Z","updated":"2019-12-30T06:26:53.000Z","comments":true,"path":"links/index.html","permalink":"http://astrapub.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"04. 数据结构与算法入门 | 排序算法(上)","slug":"alg-04","date":"2020-02-24T14:49:04.000Z","updated":"2020-02-25T08:04:41.189Z","comments":true,"path":"2020/02/24/alg-04/","link":"","permalink":"http://astrapub.github.io/2020/02/24/alg-04/","excerpt":"","text":"几种经典排序算法及其时间复杂度级别冒泡、插入、选择 O(n^2) 基于比较快排、归并 O(nlogn) 基于比较计数、基数、桶 O(n) 不基于比较 如何分析一个排序算法？ 学习排序算法的思路？明确原理、掌握实现以及分析性能。 如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。 执行效率：从以下3个方面来衡量1）最好情况、最坏情况、平均情况时间复杂度2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑3）比较次数和交换（或移动）次数 内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。 稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。 冒泡排序（Bubble Sort） 排序原理 1）冒泡排序只会操作相邻的两个数据。2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。 性能分析 执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。平均时间复杂度：通过有序度和逆序度来分析。 什么是有序度？ 有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n*(n-1)/2，也就是15，完全有序的情况称为满有序度。 什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。 排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。 冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。 对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n*(n-1)/2交换。最好情况下，初始状态有序度是n*(n-1)/2，就不需要进行交互。我们可以取个中间值n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。 以上的分析并不严格，但很实用，这就够了。 空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。 算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。 插入排序（Insertion Sort） 算法原理首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。 性能分析 时间复杂度：最好、最坏、平均情况如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。 空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。 算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。 选择排序（Selection Sort）选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 总结冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。 但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个： 12345678910111213// 冒泡排序中数据的交换操作：if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true;&#125;// 插入排序中数据的移动操作：if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动&#125; else &#123; break;&#125; 所以在实际使用中插入排序会比冒泡排序更常用。 要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看，下面是这三种排序算法的复杂度分析： 是否是原地排序 是否稳定 最好 最坏 平均 冒泡排序 是 是 O(n) O(n²) O(n²) 插入排序 是 是 O(n) O(n²) O(n²) 选择排序 是 否 O(n²) O(n²) O(n²)","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"03. 数据结构与算法入门 | 递归","slug":"alg-03","date":"2020-02-24T14:49:03.000Z","updated":"2020-02-25T07:25:43.303Z","comments":true,"path":"2020/02/24/alg-03/","link":"","permalink":"http://astrapub.github.io/2020/02/24/alg-03/","excerpt":"","text":"一言以蔽之，递归就是自己调用自己的函数，当然这么理解有点不太准确，但是当我们看到了调用自己的函数，就基本可以判断是递归函数。 递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示，比如： 123f(n) &#x3D; f(n-1) + 1;f(n) &#x3D; f(n-1) + f(n-2);f(n)&#x3D;n*f(n-1); 递归其实不太符合我们人脑的思维方式。递归需要满足一下三个条件： 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 所以递归代码的编写就需要写出递推公式，找到终止条件，即递归条件和基线条件，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 递归代码要警惕堆栈溢出，可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。 笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://astrapub.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"02. 数据结构与算法入门 | 一篇文章讲清数组、链表、栈、队列","slug":"alg-02","date":"2020-02-24T14:49:02.000Z","updated":"2020-02-25T07:04:44.494Z","comments":true,"path":"2020/02/24/alg-02/","link":"","permalink":"http://astrapub.github.io/2020/02/24/alg-02/","excerpt":"","text":"数组数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 线性表（Linear List）：顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。 非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。 数组具有随机访问特性，并且可以借助 cpu 缓存策略提高效率。数组必须存储在连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。 数组插入和删除的时间复杂度为O(n)，如果不考虑数据连续性，在插入数据的时候可以先将要插入位置的数据移到最后，然后再将数据插入，时间复杂度可降为 O(1)，删除操作亦然。数组随机访问的时间复杂度为 O(1)。 使用数组需要警惕数组的访问越界，C语言中更甚。Java 中的 ArrayList 容器，支持动态扩容，但扩容操会产生数据搬移，时间复杂度也是上升到 O(n)，使用时最好事先指定数据大小。 这里补充一个知识点，为什么数组要从 0 开始编号，而不是从 1 开始？ 从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据； 也有一定的历史原因。 链表 和数组一样，链表也是一种线性表。 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。 链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。 链表分为单向链表、双向链表、循环链表、双向循环链表。链表的删除和插入操作时间复杂度为O(1)，只需改变指针的值，查找的时间复杂度为O(n)。 选择数组还是链表？ 插入、删除和随机访问的时间复杂度 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。 数组缺点 若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。 链表缺点 内存空间消耗更大，因为需要额外的空间存储指针信息。对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。 如何选择？ 数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。如果代码对内存的使用非常苛刻，那数组就更适合。 栈后进者先出，先进者后出，这就是典型的“栈”结构。有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。 从栈的操作特性上来看，其实，栈是一种“操作受限”的线性表，只允许在端插入和删除数据，只支持两个基本操作：入栈 push()和出栈 pop()。栈根据实现方法不同可以分为顺序栈和链式栈。 栈的应用： 函数调用中的应用，操作系统给每个线程分配了一块独立的内存空间； 栈在表达式求值中的应用（比如：34+13*9+44-12/3）； 栈在括号匹配中的应用（比如：{}{()}），可用于代码编译； 实现浏览器的前进后退功能 JVM 内存管理中有个“堆栈”的概念和内存中的栈有何区别？ 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。 真实的堆栈应该和计算机架构有关，cpu有栈顶指针寄存器，然后指令有push和pop的指令，这个是数字电路作死的，函数之间的跳变，编译器把要跳的地址赋值给栈顶指针寄存器，然后根据你写的代码编译成push和pop，这部分代码对写高级语言的程序员是透明的，如果写汇编，这些都得自己写 队列先进者先出，这就是典型的“队列”，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。和栈一样，队列也是一种操作受限的线性表。 常用的队列 阻塞队列 在队列的基础上增加阻塞操作，就成了阻塞队列； 阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回； 从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。 并发队列 在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列； 并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作； 实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。 线程池资源枯竭的处理 在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数组","slug":"数组","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"http://astrapub.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://astrapub.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://astrapub.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"01. 数据结构与算法入门 | 什么是复杂度分析","slug":"alg-01","date":"2020-02-24T14:49:01.000Z","updated":"2020-02-25T04:07:09.372Z","comments":true,"path":"2020/02/24/alg-01/","link":"","permalink":"http://astrapub.github.io/2020/02/24/alg-01/","excerpt":"","text":"复杂度分析分为时间复杂度分析和空间复杂度分析，时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 什么是复杂度分析？ 数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。 为什么使用复杂度分析？ 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。 如何进行复杂度分析？ 大O表示法 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。 空间复杂度分析比时间复杂度分析要简单很多，我们常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 复杂度分析法则 单段代码看高频：比如循环。 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。 嵌套代码求乘积：比如递归、多重循环等 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 常用的复杂度级别多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶） 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶） 复杂度分析的4个概念 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 为什么要引入这4个概念？ 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 如何分析平均、均摊时间复杂度？ 平均时间复杂度 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。 均摊时间复杂度 两个条件满足时使用： 代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度； 低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://astrapub.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}]},{"title":"00. 数据结构与算法入门 | 开篇，如何学习","slug":"alg-00","date":"2020-02-24T14:49:00.000Z","updated":"2020-02-25T04:27:34.101Z","comments":true,"path":"2020/02/24/alg-00/","link":"","permalink":"http://astrapub.github.io/2020/02/24/alg-00/","excerpt":"","text":"什么是数据结构，什么是算法大部分教材里开篇都会有相关的定义，但是这些定义都很抽象，而且对于我们理解没有什么实质性帮助，所以我们不必死扣定义。那么来讲讲我的理解，数据结构就是指一组数据的存储结构，算法就是操作数据的一组方法。 可以以图书馆为例，为了方便查找，图书管理员把图书会按照一定规律放到书架上，这就是书籍这种“数据”的存储结构，而怎么才能查到一本书的具体位置，方法有很多，可以一本一本的找，也可以将图书分类然后再查找，这个查找的方法就是算法。 所以，数据结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。 学习数据结构与算法的重要性 直接好处是能够有写出性能更优的代码。 算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面。 长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。 知识体系 学习技巧数据结构与算法学习，其实是一个很枯燥的过程，很容易就坚持不下来，其实可以使用学习技巧来提升学习体验： 边学边练，适度刷题； 多问、多思考、多互动，最好能和志同道合的朋友一起学习； 给自己设立一个切实可行的目标，就像打怪升级，坚持下来； 反复迭代、温故知新，不断沉淀。 学习的方法论首先我认为学习分两点，第一，知识点的学习，主要是记忆和理解，相对简单，有清晰的目标，有良好的正反馈，学会了就是会了，可以拿来炫耀。比如，我可以告诉你帆船是通过走之字型逆风航行的，相信你很容易就能明白并记住这个知识点，但是你就能因此学会了如何驾驶帆船么，并不能，那么久引出了下面的内容；第二，技能的学习，这就需要刻意练习，不断纠正自己的错误，标准不清晰也就不容易量化，不容易形成正反馈，也就容易放弃。最典型的就是学习英语，需要反复练习，编程亦然，需要练习。 所以我总结以下几点关于学习的方法，希望和大家一起交流： 首先提高知识的广度，建立知识体系，再去拓展知识的深度； 制定切实可行的目标，一步一步来； 建立正反馈系统，可以跟牛人学，也可以和朋友一起学，对于错误能及时发现、及时纠正； 持续输出，可以写学习笔记、总结，也可以是代码和注释，如果能教会别人效果更佳； 坚持学习和健身，健身能够增加多巴胺的分泌，能使人身心愉悦，同时能提升延迟满足的能力，提高学习效率。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数组","slug":"数组","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"http://astrapub.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://astrapub.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://astrapub.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"算法入门——排序算法","slug":"alg-order","date":"2020-01-14T06:30:40.000Z","updated":"2020-01-17T08:14:43.425Z","comments":true,"path":"2020/01/14/alg-order/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-order/","excerpt":"","text":"选择排序如果有一组数，按从大到小排列，遍历列表，找出最大的数并添加到一个新列表，再次这样做，找出第二大的数，以此类推，这样便可得到一个有序列表。 示例1234567891011121314151617181920212223// 找出最大元素function findLargest(arr)&#123; let largest = arr[0]; let largestIndex = 0; for (let i in arr)&#123; if (arr[i] &gt; largest) &#123; largest = arr[i]; largestIndex = i; &#125; &#125; return largestIndex;&#125;// 对数组进行排序 function selectionSort(arr)&#123; let newArr = [] while(arr.length &gt; 0)&#123; let largest = findLargest(arr); newArr.push(arr.splice(largest, 1)[0]) &#125; return newArr&#125;console.log(selectionSort([5, 3, 6, 2, 10])); 选择排序需要的总时间为 O(n × n)，即O(n2)。 需要检查的元素数越来越少 随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一 个。既然如此，运行时间怎么还是O(n2)呢?这个问题问得好，这与大O表示法中的常数相关，后面有机会我还详细解释一下。 没错，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素 数依次为n - 1, n - 2, …, 2和1。平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。 但大O表示法省略诸如1/2这样的常数，因此简单地写 作O(n × n)或O(n2)。 选择排序是一种灵巧的算法，但其速度不是很快。 快速排序分而治之在介绍快速排序之前先介绍一下“分而治之”（divide and conquer，D&amp;C），一种著名的递归问题解决方法。使用D&amp;C解决问题的过程包括两个步骤： 找出基线条件，这种条件必须尽可能简单。 不断将问题分解(或者说缩小规模)，直到符合基线条件。 D&amp;C 的工作原理： 找出简单的基线条件。 确定如何缩小问题的规模，使其符合基线条件。 D&amp;C 并非可用于解决问题的算法，而是一种解决问题的思路。 快速排序快速排序是一种常用的排序算法，比选择排序快得多。例如，C 语言标准库中的函数 qsort 实现的就是快速排序。快速排序也使用了 D&amp;C。首先根据 D&amp;C 的步骤，我们需要找到基线条件：数组为空或只包含一个元素。在这种情况下，只需原样返回数组——根本就不用排序。然后缩小问题：分解数组，直到满足基线条件。从数组中选一个元素，作为基准值（pivot）。接下来，找出比基准值小的元素以及比基准值大的元素，这个过程被称为分区（partitioning），会得到： 一个由所有小于基准值的数字组成的子数组 基准值 一个由所有大于基准值的数组组成的子数组 我们将得到的两个子数组再进行上述操作，直到都满足基线条件。这样我们便得到一个有序列表。 12345678910111213141516171819function quicksort(arr) &#123; if (arr.length &lt; 2)&#123; return arr &#125; else &#123; // 递归条件 let pivot = arr[0]; let less = []; let greater = []; for (let i in arr)&#123; if (arr[i] &lt; pivot)&#123; less.push(arr[i]) &#125; else if (arr[i] &gt; pivot)&#123; greater.push(arr[i]) &#125; &#125; return [...quicksort(less), pivot, ...quicksort(greater) ] &#125;&#125;console.log(quicksort([5, 3, 6, 2, 10])); 分解数组的过程使用了归纳证明的思想，如果是两个元素的数组我们可以轻易对其排序，那如果是三个元素呢，我们可以将其拆分为两个元素的数组，和一个元素的数组，以此类推我们可以对任意长度数组进行拆分，那么我们可以任意长度数组排序。 归纳证明 归纳证明是一种证明算法行之有效的方式，它分两步:基线 条件和归纳条件。是不是有点似曾相识的感觉?例如，假设我要证明我能爬到梯子的最上面。 递归条件是这样的:如果我站在一个横档上，就能将脚放到下一个横档上。换言之，如果我站 在第二个横档上，就能爬到第三个横档。这就是归纳条件。而基线条件是这样的，即我已经站 在第一个横档上。因此，通过每次爬一个横档，我就能爬到梯子最顶端。 对于快速排序，可使用类似的推理。在基线条件中，我证明这种算法对空数组或包含一个 元素的数组管用。在归纳条件中，我证明如果快速排序对包含一个元素的数组管用，对包含两 个元素的数组也将管用;如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用， 以此类推。因此，我可以说，快速排序对任何长度的数组都管用。这里不再深入讨论归纳证明， 但它很有趣，并与D&amp;C协同发挥作用。 快速排序的速度取决于选择的基准值，在最糟情况下，其运行时间为O(n2)。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"Promise、Async/Await 备忘","slug":"js-promise","date":"2020-01-06T07:17:56.000Z","updated":"2020-01-07T06:19:55.568Z","comments":true,"path":"2020/01/06/js-promise/","link":"","permalink":"http://astrapub.github.io/2020/01/06/js-promise/","excerpt":"","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise 可以理解为一个容器，保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 有all、reject、resolve 这几个方法，原型上有then、catch等方法。 有以下特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 setTimeout、Promise、Async/Await 的区别其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行； promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。 也就是说执行顺序是：任务栈（包括await后面的表达式）&gt; 微任务队列（promise.then回调，await下面的表达式）&gt; 宏任务队列（setTimeout回调）。 多个异步任务Promise 还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用 Promise 需要写一层一层的嵌套代码。有了 Promise，我们只需要简单地写： 1job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是 Promise 对象。 参考https://www.jianshu.com/p/7c6e4d21bf77https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7async/await 执行顺序详解Promise原理与实现ES6 入门之 Promise 对象","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://astrapub.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://astrapub.github.io/tags/js/"},{"name":"Promise","slug":"Promise","permalink":"http://astrapub.github.io/tags/Promise/"}]},{"title":"深刻理解 Javascript 的 this 指向","slug":"js-this","date":"2020-01-05T14:52:35.000Z","updated":"2020-01-06T03:18:18.977Z","comments":true,"path":"2020/01/05/js-this/","link":"","permalink":"http://astrapub.github.io/2020/01/05/js-this/","excerpt":"","text":"现象首先我们来看一段代码 1234567891011let a = 2;let obj = &#123; a: 1, foo: function () &#123; console.log(this.a) &#125;&#125;;let foo = obj.foo;// 写法一obj.foo()// 写法二foo() 写法一和写法二的执行结果分别是：1、2。之所以运行结果不用，是因为方法中使用了 this 关键字。this 指代方法调用者，即运行时的环境。对于obj.foo()，foo 运行在 obj 中，所以 this 指向 obj。而 foo()，foo 运行在全局，所以 this 指向全局。由此得出结论： 普通函数的 this 总是指向它的直接调用者。 在严格模式下，没找到直接调用者，则函数中的 this 是 undefined。 在默认模式下（非严格模式），没找到直接调用者，则函数中的 this 指向 window。 this 的由来JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 内存数据结果1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。Javascript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 12345678&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125; 注意，foo属性的值保存在属性描述对象的value属性里面。 函数这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 123456&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125; 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() 环境变量Javascript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量x。该变量由运行环境提供。现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的this.x就是指当前运行环境的x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x指向全局环境的x。在obj环境执行，this.x指向obj.x。回到本文开头提出的问题，obj.foo()是通过obj找到foo，所以就是在obj环境执行。一旦var foo = obj.foo，变量foo就直接指向函数本身，所以foo()就变成在全局环境执行。 箭头函数在 ES6 中新增的箭头函数，不仅简化了代码，还解决 this 飘忽不定的指向问题。 12345678var obj = &#123; a : 1, foo : function()&#123; setTimeout( function()&#123;console.log(this.a),3000&#125;) &#125;&#125;obj.foo(); //undefined 此代码运行结果为 undefined，this 的指向是全局的 window 对象。 1()=&gt;&#123;console.log(this)&#125; 其中()内是要带入的参数，{}内是要执行的语句。箭头函数是函数式编程的一种体现，函数式编程将更多的关注点放在输入和输出的关系，省去了过程的一些因素，因此箭头函数中没有自己的 this，arguments，new target（ES6）和 super(ES6)。箭头函数相当于匿名函数，因此不能使用new来作为构造函数使用。箭头函数中的 this 始终指向其父级作用域中的 this 。换句话说，箭头函数会捕获其所在的上下文的 this 值，作为自己的 this 值。任何方法都改变不了其指向，如 call(), bind(), apply()。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用，它与调用时的上下文无关。我们用代码来解释一下。 参考 阮一峰的 《JavaScript 的 this 原理》 《ES6箭头函数与普通函数的区别》","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://astrapub.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://astrapub.github.io/tags/js/"},{"name":"this","slug":"this","permalink":"http://astrapub.github.io/tags/this/"},{"name":"箭头函数","slug":"箭头函数","permalink":"http://astrapub.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}]},{"title":"2019回顾，2020展望","slug":"review2019","date":"2020-01-04T14:12:17.000Z","updated":"2020-01-05T12:41:49.679Z","comments":true,"path":"2020/01/04/review2019/","link":"","permalink":"http://astrapub.github.io/2020/01/04/review2019/","excerpt":"","text":"进入 2020 年已经4个日子了，每次跨年觉得应该有仪式感。当跨年的那一刻，2019像电影一样在脑海过了一遍，不禁要问2019都干了什么。从毕业到现在从事开发工作已经整整5个年头，有感动也有遗憾，5年的时间想想如果能坚持做一件事想想现在应该也小有成就了。 2019其实是寻找的一年，寻找自己，寻找答案。我不知道答案是否找到了，但确实明白了一些事，不再幻想，不再漫不经心，不再天马星空。越来越明白踏实做事的重要性，不再轻易被情绪控制，不卑不亢。明白世界运行的规律，独立思考，不被洗脑。 2019也是不破不立的一年，这一年经历了很多，跌宕起伏。值得庆幸的是这一年我跳出了自己的舒适圈，直面自己的弱点，虽然过程会有痛苦，但成长的喜悦难以言表，有些困难过去了就真的过去了。 目标重要，如何实现目标更重要，还是要有计划，有些看似困难的问题，其实都是有解的，掌握方式方法，刻意去练习，进步会很快。 2020，持续做好要做的事，丰富自己的知识体系，建立个人品牌，将博客继续写下去，持续写作，如果条件允许出系列教程。 review 系列也要继续写下去。","categories":[{"name":"回顾","slug":"回顾","permalink":"http://astrapub.github.io/categories/%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"回顾","slug":"回顾","permalink":"http://astrapub.github.io/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"总结","slug":"总结","permalink":"http://astrapub.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"2019","slug":"2019","permalink":"http://astrapub.github.io/tags/2019/"}]},{"title":"Hexo 使用教程","slug":"hexo-course","date":"2020-01-03T09:16:49.000Z","updated":"2020-01-04T08:18:57.647Z","comments":true,"path":"2020/01/03/hexo-course/","link":"","permalink":"http://astrapub.github.io/2020/01/03/hexo-course/","excerpt":"","text":"安装首先需要安装 node.js，node.js 安装教程可参看 https://www.runoob.com/nodejs/nodejs-install-setup.html然后执行npm install -g hexo 或 yarn global add hexo 安装 Hexo。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm i 或 yarn install 目录结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 在执行 hexo init 的时候可能git会报错，可以到 https://github.com/hexojs/hexo-starter.git 这个地址直接把 Hexo 项目下载下来，然后改成自己项目名字。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 scaffold/post.md 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。 _config.yml网站的配置信息，可以配置网站名称、关键字、语言、作者、时区等信息。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题文件夹。可以去 https://hexo.io/themes/ 寻找喜欢的主题。 安装主题我使用的主题是 pure 启用主题在你的 hexo 项目文件夹下执行： 1git clone https:&#x2F;&#x2F;github.com&#x2F;cofess&#x2F;hexo-theme-pure.git themes&#x2F;pure 修改配置文件 hexo/_config.yml 中 theme 为 pure。 gitalk 评论Gitalk 是一个基于 Github Issue 的评论插件，每增加一条评论相应的在 GitHub 项目增加一条 Issue。 注册 GitHub Application到 https://github.com/settings/applications/new 注册 GitHub Application填写 Application name（项目名称），Homepage URL（博客链接），Application description（描述），authorization callback URL（回调地址，博客链接）等信息，完成注册，获取到 Client ID 和 Client Secret。如果项目在 Organization 下，需要进入到相应的 Organization，点击 Settings &gt; OAuth Apps，注册 GitHub Application。 配置 _config.yml配置文件位置 themes/pure/_config.yml。修改 comment &gt; type 为：gitalk，将 Client ID 和 Client Secret 填写的相应位置，并填写 owner，admin，repo。owner 为项目所有者，如果是 Organization，这填写 Organization 名称。admin 为你的用户名，repo 对应 GitHub 中的项目名。 常用命令创建一个新网站1hexo init [folder] 新建一篇文章1$ hexo new [layout] &lt;title&gt; layout 可选，如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。如： 1$ hexo new &quot;post title with whitespace&quot; 参数 描述 -p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about&#x2F;me &quot;About me&quot; 生成静态文件1$ hexo generate 或 g 参数 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 示例检测文件变动实时预览： 1$ hexo g -w 生成文件自动部署： 1$ hexo g -d 启动服务器1$ hexo server 或 s 默认情况下，访问网址为： http://localhost:4000/。 部署1$ hexo deploy 部署方式请看 https://hexo.io/zh-cn/docs/one-command-deployment 清除缓存文件1$ hexo clean","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://astrapub.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://astrapub.github.io/tags/Hexo/"}]},{"title":"计划","slug":"plan","date":"2020-01-02T05:53:24.000Z","updated":"2020-01-02T05:53:24.166Z","comments":true,"path":"2020/01/02/plan/","link":"","permalink":"http://astrapub.github.io/2020/01/02/plan/","excerpt":"","text":"","categories":[],"tags":[]}]}