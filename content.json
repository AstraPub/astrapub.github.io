{"meta":{"title":"Astra","subtitle":"","description":"Astra 个人博客","author":"Astra","url":"http://astrapub.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-01-02T06:08:50.375Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"/404.html","permalink":"http://astrapub.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-25T07:29:46.242Z","updated":"2020-02-25T07:29:46.241Z","comments":false,"path":"about/index.html","permalink":"http://astrapub.github.io/about/index.html","excerpt":"","text":"名字: Astra年龄: 28性别: 男职业: 软件工程师经验: 6年地址: 北京学历: 本科github: https://github.com/atoveBlog: https://astrapub.github.io"},{"title":"书单","date":"2020-01-02T06:08:50.405Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"books/index.html","permalink":"http://astrapub.github.io/books/index.html","excerpt":"","text":""},{"title":"About me","date":"2019-12-28T03:18:52.000Z","updated":"2019-12-28T03:39:16.509Z","comments":true,"path":"about/me.html","permalink":"http://astrapub.github.io/about/me.html","excerpt":"","text":"hex"},{"title":"分类","date":"2020-01-02T06:08:50.421Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"categories/index.html","permalink":"http://astrapub.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-01-02T06:08:50.457Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"repository/index.html","permalink":"http://astrapub.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-02T06:08:50.473Z","updated":"2019-12-30T06:26:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://astrapub.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-01-02T06:08:50.439Z","updated":"2019-12-30T06:26:53.000Z","comments":true,"path":"links/index.html","permalink":"http://astrapub.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"10. 数据结构与算法入门 | 散列表","slug":"alg-10","date":"2020-01-15T12:32:09.000Z","updated":"2020-02-25T13:26:31.576Z","comments":true,"path":"2020/01/15/alg-10/","link":"","permalink":"http://astrapub.github.io/2020/01/15/alg-10/","excerpt":"","text":"散列表的由来 散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。 需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。 将数据存储在散列值对应的数组下标位置。 如何设计散列函数？总结3点设计散列函数的基本要求 散列函数计算得到的散列值是一个非负整数。 若key1=key2，则hash(key1)=hash(key2) 若key≠key2，则hash(key1)≠hash(key2)正是由于第3点要求，所以产生了几乎无法避免的散列冲突问题。 散列冲突的解放方法？ 常用的散列冲突解决方法有2类：开放寻址法（open addressing）和链表法（chaining） 开放寻址法 ①核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。 ②线性探测法（Linear Probing）： 插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。 查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。 删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。 结论：最坏时间复杂度为O(n) ③二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。 ④双重散列（Double hashing）：使用一组散列函数，直到找到空闲位置为止。 ⑤线性探测法的性能描述： 用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数/散列表的长度。装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 链表法（更常用） 插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。 查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。 如何设计一个工业级的散列函数？思路： 何为一个工业级的散列表？工业级的散列表应该具有哪些特性？结合学过的知识，我觉的应该有这样的要求： 支持快速的查询、插入、删除操作； 内存占用合理，不能浪费过多空间； 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。 方案： 如何设计这样一个散列表呢？根据前面讲到的知识，我会从3个方面来考虑设计思路： 设计一个合适的散列函数； 定义装载因子阈值，并且设计动态扩容策略； 选择合适的散列冲突解决方法。 如何设计散列函数？ 要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。 除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。 常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。 如何根据装载因子动态扩容？ 如何设置装载因子阈值？ ① 可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法。 ② 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。 如何避免低效扩容？分批扩容 ① 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。 ② 分批扩容的查询操作：先查新散列表，再查老散列表。 ③ 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。 如何选择散列冲突解决方法？ 常见的两种方法：开放寻址法和链表法。 大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。 但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。 为什么散列表和链表经常放在一起使用？ 散列表的优点：支持高效的数据插入、删除和查找操作 散列表的缺点：不支持快速顺序遍历散列表中的数据 如何按照顺序快速遍历散列表的数据？只能将数据转移到数组，然后排序，最后再遍历数据。 我们知道散列表是动态的数据结构，需要频繁的插入和删除数据，那么每次顺序遍历之前都需要先排序，这势必会造成效率非常低下。 如何解决上面的问题呢？就是将散列表和链表（或跳表）结合起来使用。 散列表和链表如何组合起来使用 LRU（Least Recently Used）缓存淘汰算法 1.1. LRU缓存淘汰算法主要操作有哪些？主要包含3个操作： ① 往缓存中添加一个数据；② 从缓存中删除一个数据；③ 在缓存中查找一个数据；④ 总结：上面3个都涉及到查找。 1.2. 如何用链表实现LRU缓存淘汰算法？ ① 需要维护一个按照访问时间从大到小的有序排列的链表结构。② 缓冲空间有限，当空间不足需要淘汰一个数据时直接删除链表头部的节点。③ 当要缓存某个数据时，先在链表中查找这个数据。若未找到，则直接将数据放到链表的尾部。若找到，就把它移动到链表尾部。④ 前面说了，LRU缓存的3个主要操作都涉及到查找，若单纯由链表实现，查找的时间复杂度很高为O(n)。若将链表和散列表结合使用，查找的时间复杂度会降低到O(1)。 1.3. 如何使用散列表和链表实现LRU缓存淘汰算法？ ① 使用双向链表存储数据，链表中每个节点存储数据（data）、前驱指针（prev）、后继指针（next）和hnext指针（解决散列冲突的链表指针）。② 散列表通过链表法解决散列冲突，所以每个节点都会在两条链中。一条链是双向链表，另一条链是散列表中的拉链。前驱和后继指针是为了将节点串在双向链表中，hnext指针是为了将节点串在散列表的拉链中。③ LRU缓存淘汰算法的3个主要操作如何做到时间复杂度为O(1)呢？首先，我们明确一点就是链表本身插入和删除一个节点的时间复杂度为O(1)，因为只需更改几个指针指向即可。 接着，来分析查找操作的时间复杂度。当要查找一个数据时，通过散列表可实现在O(1)时间复杂度找到该数据，再加上前面说的插入或删除的时间复杂度是O(1)，所以我们总操作的时间复杂度就是O(1)。 Redis有序集合 2.1.什么是有序集合？ ① 在有序集合中，每个成员对象有2个重要的属性，即key（键值）和score（分值）。② 不仅会通过score来查找数据，还会通过key来查找数据。 2.2. 有序集合的操作有哪些？ 举个例子，比如用户积分排行榜有这样一个功能：可以通过用户ID来查找积分信息，也可以通过积分区间来查找用户ID。这里用户ID就是key，积分就是score。所以，有序集合的操作如下： ① 添加一个对象；② 根据键值删除一个对象；③ 根据键值查找一个成员对象；④ 根据分值区间查找数据，比如查找积分在[100.356]之间的成员对象；⑤ 按照分值从小到大排序成员变量。 这时可以按照分值将成员对象组织成跳表结构，按照键值构建一个散列表。那么上面的所有操作都非常高效。 Java LinkedHashMap和LRU缓存淘汰策略实现一模一样。支持按照插入顺序遍历数据，也支持按照访问顺序遍历数据。 思考 Word文档中单词拼写检查功能是如何实现的？ 答：字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。 假设我们有10万条URL访问日志，如何按照访问次数给URL排序？ 答：字符串占用内存大小为8字节，10万条URL访问日志占用内存不超过10MB，通过散列表统计url访问次数，然后用TreeMap存储散列表的元素值（作为key）和数组下标值（作为value） 有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？ 答：分别将2个数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数。注意，先存储的数组中的相同元素值不进行次数累加。最后，统计散列表中元素值大于等于2的散列值对应的字符串就是两个数组中相同的字符串。 上面所讲的几个散列表和链表组合的例子里，我们都是使用双向链表。如果把双向链表改成单链表，还能否正常工作？为什么呢？ 答： 在删除一个元素时，虽然能 O(1) 的找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 O(N），所以用双链表实现比较合适。 假设猎聘网有10万名猎头，每个猎头可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头的ID和积分信息，让它能够支持这样几个操作： 1）根据猎头ID查收查找、删除、更新这个猎头的积分信息；2）查找积分在某个区间的猎头ID列表；3）查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。 答：以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。1）ID 在散列表中所以可以 O(1) 查找到这个猎头；2）积分以跳表存储，跳表支持区间查询；3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"散列表","slug":"散列表","permalink":"http://astrapub.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"09. 数据结构与算法入门 | 跳表","slug":"alg-09","date":"2020-01-15T12:32:09.000Z","updated":"2020-02-25T13:15:56.450Z","comments":true,"path":"2020/01/15/alg-09/","link":"","permalink":"http://astrapub.github.io/2020/01/15/alg-09/","excerpt":"","text":"什么是跳表？为一个值有序的链表建立多级索引，比如每2个节点提取一个节点到上一级，我们把抽出来的那一级叫做索引或索引层。如下图所示，其中down表示down指针，指向下一级节点。以此类推，对于节点数为n的链表，大约可以建立log2n-1级索引。像这种为链表建立多级索引的数据结构就称为跳表。 跳表的时间复杂度？ 计算跳表的高度 如果链表有n个节点，每2个节点抽取抽出一个节点作为上一级索引的节点，那第1级索引的节点个数大约是n/2，第2级索引的节点个数大约是n/4，依次类推，第k级索引的节点个数就是n/(2^k)。假设索引有h级别，最高级的索引有2个节点，则有n/(2^h)=2，得出h=log2n-1，包含原始链表这一层，整个跳表的高度就是log2n。 计算跳表的时间复杂度 假设我们在跳表中查询某个数据的时候，如果每一层都遍历m个节点，那在跳表中查询一个数据的时间复杂度就是O(m*logn)。那这个m是多少呢？如下图所示，假设我们要查找的数据是x，在第k级索引中，我们遍历到y节点之后，发现x大于y，小于后面的节点z，所以我们通过y的down指针，从第k级下降到第k-1级索引。在第k-1级索引中，y和z之间只有3个节点（包含y和z），所以，我们在k-1级索引中最多只需要遍历3个节点，以此类推，每一级索引都最多只需要遍历3个节点。所以m=3。因此在跳表中查询某个数据的时间复杂度就是O(logn)。 跳表的空间复杂度及如何优化？ 计算索引的节点总数 如果链表有n个节点，每2个节点抽取抽出一个节点作为上一级索引的节点，那每一级索引的节点数分别为：n/2，n/4，n/8，…，8，4，2，等比数列求和n-1，所以跳表的空间复杂度为O(n)。 如何优化时间复杂度 如果链表有n个节点，每3或5个节点抽取抽出一个节点作为上一级索引的节点，那每一级索引的节点数分别为（以3为例）：n/3，n/9，n/27，…，27，9，3，1，等比数列求和n/2，所以跳表的空间复杂度为O(n)，和每2个节点抽取一次相比，时间复杂度要低不少呢。 高效的动态插入和删除？跳表本质上就是链表，所以仅插作，插入和删除操时间复杂度就为O(1)，但在实际情况中，要插入或删除某个节点，需要先查找到指定位置，而这个查找操作比较费时，但在跳表中这个查找操作的时间复杂度是O(logn)，所以，跳表的插入和删除操作的是时间复杂度也是O(logn)。 跳表索引动态更新？当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中，那么如何选择这个索引层呢？可以通过随机函数来决定将这个节点插入到哪几级索引中，比如随机函数生成了值K，那就可以把这个节点添加到第1级到第K级索引中。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"跳表","slug":"跳表","permalink":"http://astrapub.github.io/tags/%E8%B7%B3%E8%A1%A8/"}]},{"title":"08. 数据结构与算法入门 | 二分查找","slug":"alg-08","date":"2020-01-15T12:32:08.000Z","updated":"2020-02-25T13:12:08.664Z","comments":true,"path":"2020/01/15/alg-08/","link":"","permalink":"http://astrapub.github.io/2020/01/15/alg-08/","excerpt":"","text":"什么是二分查找？二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。 时间复杂度分析？ 时间复杂度 假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。所以，每次查找的数据大小是：n，n/2，n/4，…，n/(2^k)，…，这是一个等比数列。当n/(2^k)=1时，k的值就是总共缩小的次数，也是查找的总次数。而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就是O(k)。通过n/(2^k)=1，可求得k=log2n，所以时间复杂度是O(logn)。 认识O(logn) ① 这是一种极其高效的时间复杂度，有时甚至比O(1)的算法还要高效。为什么？② 因为logn是一个非常“恐怖“的数量级，即便n非常大，对应的logn也很小。比如n等于2的32次方，也就是42亿，而logn才32。③ 由此可见，O(logn)有时就是比O(1000)，O(10000)快很多。 如何实现二分查找？ 循环实现 代码实现： 1234567891011public int binarySearch1(int[] a, int val)&#123; int start = 0; int end = a.length - 1; while(start &lt;= end)&#123; int mid = start + (end - start) / 2; if(a[mid] &gt; val) end = mid - 1; else if(a[mid] &lt; val) start = mid + 1; else return mid; &#125; return -1;&#125; 注意事项： ① 循环退出条件是：start&lt;=end，而不是start&lt;end。 ② mid的取值，使用mid=start + (end - start) / 2，而不用mid=(start + end)/2，因为如果start和end比较大的话，求和可能会发生int类型的值超出最大范围。为了把性能优化到极致，可以将除以2转换成位运算，即start + ((end - start) &gt;&gt; 1)，因为相比除法运算来说，计算机处理位运算要快得多。 ③ start和end的更新：start = mid - 1，end = mid + 1，若直接写成start = mid，end=mid，就可能会发生死循环。 递归实现 1234567891011public int binarySearch(int[] a, int val)&#123; return bSear(a, val, 0, a.length-1);&#125;private int bSear(int[] a, int val, int start, int end) &#123; if(start &gt; end) return -1; int mid = start + (end - start) / 2; if(a[mid] == val) return mid; else if(a[mid] &gt; val) end = mid - 1; else start = mid + 1; return bSear(a, val, start, end);&#125; 使用条件（应用场景的局限性） 二分查找依赖的是顺序表结构，即数组。 二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。 数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。 数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。 思考 如何在1000万个整数中快速查找某个整数？ ①1000万个整数占用存储空间为40MB，占用空间不大，所以可以全部加载到内存中进行处理； ②用一个1000万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为O(nlogn)； ③在有序数组中使用二分查找算法进行查找，时间复杂度为O(logn) 如何编程实现“求一个数的平方根”？要求精确到小数点后6位？ 四种常见的二分查找变形问题 查找第一个值等于给定值的元素 查找最后一个值等于给定值的元素 查找第一个大于等于给定值的元素 查找最后一个小于等于给定值的元素 适用性分析 凡事能用二分查找解决的，绝大部分我们更倾向于用散列表或者二叉查找树，即便二分查找在内存上更节省，但是毕竟内存如此紧缺的情况并不多。 求“值等于给定值”的二分查找确实不怎么用到，二分查找更适合用在”近似“查找问题上。比如上面讲几种变体。 思考 如何快速定位出一个IP地址的归属地？ [202.102.133.0, 202.102.133.255] 山东东营市[202.102.135.0, 202.102.136.255] 山东烟台[202.102.156.34, 202.102.157.255] 山东青岛[202.102.48.0, 202.102.48.255] 江苏宿迁[202.102.49.15, 202.102.51.251] 江苏泰州[202.102.56.0, 202.102.56.255] 江苏连云港 假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢？ 如果有一个有序循环数组，比如4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法？ 有三种方法查找循环有序数组 第一种： 找到分界下标，分成两个有序数组 判断目标值在哪个有序数据范围内，做二分查找 第二种： 找到最大值的下标 x; 所有元素下标 +x 偏移，超过数组范围值的取模; 利用偏移后的下标做二分查找； 如果找到目标下标，再作 -x 偏移，就是目标值实际下标。 两种情况最高时耗都在查找分界点上，所以时间复杂度是 O(N）。 复杂度有点高，能否优化呢？ 第三种： 我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；如果目标元素在有序数组范围中，使用二分查找；如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。 时间复杂度为 O(logN)。 用JavaScript实现的最基本的思考题：array是传入的数组，value是要查找的值思路是通过对比low,high的值来判断value所在的区间，不用多循环一遍找偏移量了~ 12345678910111213141516171819202122function search(array,value)&#123; let low = 0; let high = array.length - 1; while(low &lt;= high)&#123; let mid = low + ((high - low) &gt;&gt; 1); if(value == array[low]) return low; if(value == array[high]) return high; if(value == array[mid]) return mid; if(value &gt; array[mid] &amp;&amp; value &gt; array[high] &amp;&amp; array[mid] &lt; array[low])&#123; high = mid - 1; &#125;else if(value &lt; array[mid] &amp;&amp; value &lt; array[low] &amp;&amp; array[mid] &lt; array[low])&#123; high = mid - 1; &#125;else if(value &lt; array[mid] &amp;&amp; value &gt; array[low])&#123; high = mid - 1; &#125;else&#123; low = mid + 1; &#125; &#125; return -1&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"http://astrapub.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"07. 数据结构与算法入门 | 如何实现通用、高性能的排序函数？","slug":"alg-07","date":"2020-01-15T12:31:20.000Z","updated":"2020-02-25T12:54:06.238Z","comments":true,"path":"2020/01/15/alg-07/","link":"","permalink":"http://astrapub.github.io/2020/01/15/alg-07/","excerpt":"","text":"如何选择合适的排序算法？ 排序算法一览表 排序算法 时间复杂度 是稳定排序？ 是原地排序？ 冒泡排序 O(n^2) 是 是 插入排序 O(n^2) 是 是 选择排序 O(n^2) 否 是 快速排序 O(nlogn) 否 是 归并排序 O(nlogn) 是 否 桶排序 O(n) 是 否 计数排序 O(n+k)，k是数据范围 是 否 基数排序 O(dn)，d是纬度 是 否 为什选择快速排序？线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。 如何优化快速排序？导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下： 三数取中法从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。 随机法：每次从要排序的区间中，随机选择一个元素作为分区点。 警惕快排的递归发生堆栈溢出，有2中解决方法，如下：限制递归深度，一旦递归超过了设置的阈值就停止递归。在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。 通用排序函数实现技巧 数据量不大时，可以采取用时间换空间的思路 数据量大时，优化快排分区点的选择 防止堆栈溢出，可以选择在堆上手动模拟调用栈解决 在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序 用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致 思考 Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"06. 数据结构与算法入门 | 线性排序","slug":"alg-06","date":"2020-01-15T12:31:19.000Z","updated":"2020-02-25T13:30:48.659Z","comments":true,"path":"2020/01/15/alg-06/","link":"","permalink":"http://astrapub.github.io/2020/01/15/alg-06/","excerpt":"","text":"线性排序算法介绍 线性排序算法包括桶排序、计数排序、基数排序。 线性排序算法的时间复杂度为O(n)。 此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。 对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。 桶排序（Bucket sort） 算法原理：1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。 使用条件1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。2）数据在各个桶之间分布是均匀的。 适用场景1）桶排序比较适合用在外部排序中。2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。 应用案例1）需求描述：有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序但内存有限，仅几百MB2）解决思路：扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。将100个小文件依次放入内存并用快排排序。所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。 计数排序（Counting sort） 算法原理1）计数其实就是桶排序的一种特殊情况。2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。 图解 案例分析：假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。 使用条件1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。 基数排序（Radix sort） 算法原理（以排序10万个手机号为例来说明）1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。3）经过11次排序后，手机号码就变为有序的了。4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。 图解 使用条件1）要求数据可以分割独立的“位”来比较；2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。 思考 如何根据年龄给100万用户数据排序？ 对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如经过排序后为a，c，z，D，F，B，A，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"05. 数据结构与算法入门 | 排序算法(下)","slug":"alg-05","date":"2020-01-14T14:49:05.000Z","updated":"2020-02-25T12:49:26.429Z","comments":true,"path":"2020/01/14/alg-05/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-05/","excerpt":"","text":"分治思想归并排序和快速排序都使用了分治思想。 分治思想：分治，顾明思意，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。 分治与递归的区别：分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。 分治思想也会在以后的文章继续介绍。 归并排序（Merge Sort）先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下 12递推公式：merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;&#x3D; r 不用再继续分解 图解： 代码实现1234567891011121314151617181920212223242526272829303132333435363738// 归并排序算法, A 是数组，n 表示数组大小merge_sort(A, n) &#123; merge_sort_c(A, 0, n-1)&#125;// 递归调用函数merge_sort_c(A, p, r) &#123; // 递归终止条件 if p &gt;= r then return // 取 p 到 r 之间的中间位置 q q = (p+r) / 2 // 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q+1, r) // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r] merge(A[p...r], A[p...q], A[q+1...r])&#125;merge(A[p...r], A[p...q], A[q+1...r]) &#123; var i := p，j := q+1，k := 0 // 初始化变量 i, j, k var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组 while i&lt;=q AND j&lt;=r do &#123; if A[i] &lt;= A[j] &#123; tmp[k++] = A[i++] // i++ 等于 i:=i+1 &#125; else &#123; tmp[k++] = A[j++] &#125; &#125; // 判断哪个子数组中有剩余的数据 var start := i，end := q if j&lt;=r then start := j, end:=r // 将剩余的数据拷贝到临时数组 tmp while start &lt;= end do &#123; tmp[k++] = A[start++] &#125; // 将 tmp 中的数组拷贝回 A[p...r] for i:=0 to r-p do &#123; A[p+i] = tmp[i] &#125;&#125; 注：merge()合并函数如果借助哨兵代码就会简洁很多 性能分析算法稳定性： 归并排序稳不稳定关键要看合并函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入tmp数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。 时间复杂度：分析归并排序的时间复杂度就是分析递归代码的时间复杂度。 如何分析递归代码的时间复杂度？ 递归的适用场景是一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。若定义求解问题a的时间是T(a)，则求解问题b、c的时间分别是T(b)和T(c)，那就可以得到这样的递推公式：T(a) = T(b) + T(c) + K，其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为： 123456789T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。T(n) = 2*T(n/2) + n； n&gt;1，其中n就是merge()函数合并两个子数组的的时间复杂度O(n)。T(n) = 2*T(n/2) + n = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n ...... = 2^k * T(n/2^k) + k * n ...... 当T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到k=log2n。将k带入上面的公式就得到T(n)=Cn+nlog2n。如用大O表示法，T(n)就等于O(nlogn)。 所以，归并排序的是复杂度时间复杂度就是O(nlogn)。 空间复杂度：归并排序算法不是原地排序算法，空间复杂度是O(n) 为什么？因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是O(n)而不是O(nlogn)呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，即在每次合并过程中都需要申请额外的内存空间，但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过n个数据的大小，所以空间复杂度是O(n)。 快速排序（Quicksort）快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。 12递推公式：quick_sort(p…r) &#x3D; quick_sort(p…q-1) + quick_sort(q+1, r)终止条件：p &gt;&#x3D; r 图解 代码实现123456789101112131415161718192021222324// 快速排序，A 是数组，n 表示数组的大小quick_sort(A, n) &#123; quick_sort_c(A, 0, n-1)&#125;// 快速排序递归函数，p,r 为下标quick_sort_c(A, p, r) &#123; if p &gt;= r then return q = partition(A, p, r) // 获取分区点 quick_sort_c(A, p, q-1) quick_sort_c(A, q+1, r)&#125;//分区函数partition(A, p, r) &#123; pivot := A[r] i := p for j := p to r-1 do &#123; if A[j] &lt; pivot &#123; swap A[i] with A[j] i := i+1 &#125; &#125; swap A[i] with A[r] return i&#125; 分区函数代码说明：通过游标i把A[p…r-1]分成2部分，A[p…i-1]的元素都是小于pivot的，我们暂且叫它“已处理区间”，A[i+1…r-1]是“未处理区间”。我们每次都从未处理区间取出一个元素A[j]，与poivt相比，如果小于pivot，则将其加入到已处理区间的尾部，也就是A[i]位置。 性能分析算法稳定性： 因为分区过程中涉及交换操作，如果数组中有两个8，其中一个是pivot，经过分区处理后，后面的8就有可能放到了另一个8的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的8作为pivot，那么分区后就会将后面的8与9进行交换。 时间复杂度：最好、最坏、平均情况 快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。 T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。T(n) = 2*T(n/2) + n； n&gt;1 所以，快排的时间复杂度也是O(nlogn)。 如果数组中的元素原来已经有序了，比如1，3，5，6，8，若每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的，需要进行大约n次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就是O(n^2)。 前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)，而且我们也有很多方法将这个概率降低。 空间复杂度：快排是一种原地排序算法，空间复杂度是O(1)。 归并排序与快速排序的区别归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？ 归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。 快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。 思考如果有多个大日志文件，需要按时间合并为一个文件，但机器内存有限，不足以同时把这些文件读取到内存，可以使用归并排序思想，先构建所有日志的 IO 流，然后没条 IO 流读取一条日志，选取时间戳最小的那个放入新文件，然后该 IO 流读取下一条日志，持续这个操作，直至所有文件读取完毕。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"04. 数据结构与算法入门 | 排序算法(上)","slug":"alg-04","date":"2020-01-14T14:49:04.000Z","updated":"2020-02-25T12:04:23.705Z","comments":true,"path":"2020/01/14/alg-04/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-04/","excerpt":"","text":"几种经典排序算法及其时间复杂度级别冒泡、插入、选择 O(n^2) 基于比较快排、归并 O(nlogn) 基于比较计数、基数、桶 O(n) 不基于比较 如何分析一个排序算法？ 学习排序算法的思路？明确原理、掌握实现以及分析性能。 如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。 执行效率：从以下3个方面来衡量1）最好情况、最坏情况、平均情况时间复杂度2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑3）比较次数和交换（或移动）次数 内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。 稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。 冒泡排序（Bubble Sort） 排序原理 1）冒泡排序只会操作相邻的两个数据。2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。 性能分析 执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。平均时间复杂度：通过有序度和逆序度来分析。 什么是有序度？ 有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n*(n-1)/2，也就是15，完全有序的情况称为满有序度。 什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。 排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。 冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。 对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n*(n-1)/2交换。最好情况下，初始状态有序度是n*(n-1)/2，就不需要进行交互。我们可以取个中间值n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。 以上的分析并不严格，但很实用，这就够了。 空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。 算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。 插入排序（Insertion Sort） 算法原理首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。 性能分析 时间复杂度：最好、最坏、平均情况如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。 空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。 算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。 选择排序（Selection Sort）选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 总结冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。 但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个： 12345678910111213// 冒泡排序中数据的交换操作：if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true;&#125;// 插入排序中数据的移动操作：if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动&#125; else &#123; break;&#125; 所以在实际使用中插入排序会比冒泡排序更常用。 要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看，下面是这三种排序算法的复杂度分析： 是否是原地排序 是否稳定 最好 最坏 平均 冒泡排序 是 是 O(n) O(n²) O(n²) 插入排序 是 是 O(n) O(n²) O(n²) 选择排序 是 否 O(n²) O(n²) O(n²)","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://astrapub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"03. 数据结构与算法入门 | 递归","slug":"alg-03","date":"2020-01-14T14:49:03.000Z","updated":"2020-02-25T12:04:28.808Z","comments":true,"path":"2020/01/14/alg-03/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-03/","excerpt":"","text":"一言以蔽之，递归就是自己调用自己的函数，当然这么理解有点不太准确，但是当我们看到了调用自己的函数，就基本可以判断是递归函数。 递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示，比如： 123f(n) &#x3D; f(n-1) + 1;f(n) &#x3D; f(n-1) + f(n-2);f(n)&#x3D;n*f(n-1); 递归其实不太符合我们人脑的思维方式。递归需要满足一下三个条件： 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 所以递归代码的编写就需要写出递推公式，找到终止条件，即递归条件和基线条件，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 递归代码要警惕堆栈溢出，可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。 笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://astrapub.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"02. 数据结构与算法入门 | 一篇文章讲清数组、链表、栈、队列","slug":"alg-02","date":"2020-01-14T14:49:02.000Z","updated":"2020-02-25T12:04:33.038Z","comments":true,"path":"2020/01/14/alg-02/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-02/","excerpt":"","text":"数组数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 线性表（Linear List）：顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。 非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。 数组具有随机访问特性，并且可以借助 cpu 缓存策略提高效率。数组必须存储在连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。 数组插入和删除的时间复杂度为O(n)，如果不考虑数据连续性，在插入数据的时候可以先将要插入位置的数据移到最后，然后再将数据插入，时间复杂度可降为 O(1)，删除操作亦然。数组随机访问的时间复杂度为 O(1)。 使用数组需要警惕数组的访问越界，C语言中更甚。Java 中的 ArrayList 容器，支持动态扩容，但扩容操会产生数据搬移，时间复杂度也是上升到 O(n)，使用时最好事先指定数据大小。 这里补充一个知识点，为什么数组要从 0 开始编号，而不是从 1 开始？ 从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据； 也有一定的历史原因。 链表 和数组一样，链表也是一种线性表。 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。 链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。 链表分为单向链表、双向链表、循环链表、双向循环链表。链表的删除和插入操作时间复杂度为O(1)，只需改变指针的值，查找的时间复杂度为O(n)。 选择数组还是链表？ 插入、删除和随机访问的时间复杂度 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。 数组缺点 若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。 链表缺点 内存空间消耗更大，因为需要额外的空间存储指针信息。对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。 如何选择？ 数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。如果代码对内存的使用非常苛刻，那数组就更适合。 栈后进者先出，先进者后出，这就是典型的“栈”结构。有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。 从栈的操作特性上来看，其实，栈是一种“操作受限”的线性表，只允许在端插入和删除数据，只支持两个基本操作：入栈 push()和出栈 pop()。栈根据实现方法不同可以分为顺序栈和链式栈。 栈的应用： 函数调用中的应用，操作系统给每个线程分配了一块独立的内存空间； 栈在表达式求值中的应用（比如：34+13*9+44-12/3）； 栈在括号匹配中的应用（比如：{}{()}），可用于代码编译； 实现浏览器的前进后退功能 JVM 内存管理中有个“堆栈”的概念和内存中的栈有何区别？ 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。 真实的堆栈应该和计算机架构有关，cpu有栈顶指针寄存器，然后指令有push和pop的指令，这个是数字电路作死的，函数之间的跳变，编译器把要跳的地址赋值给栈顶指针寄存器，然后根据你写的代码编译成push和pop，这部分代码对写高级语言的程序员是透明的，如果写汇编，这些都得自己写 队列先进者先出，这就是典型的“队列”，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。和栈一样，队列也是一种操作受限的线性表。 常用的队列 阻塞队列 在队列的基础上增加阻塞操作，就成了阻塞队列； 阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回； 从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。 并发队列 在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列； 并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作； 实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。 线程池资源枯竭的处理 在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数组","slug":"数组","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"http://astrapub.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://astrapub.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://astrapub.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"01. 数据结构与算法入门 | 什么是复杂度分析","slug":"alg-01","date":"2020-01-14T14:49:01.000Z","updated":"2020-02-25T12:04:37.009Z","comments":true,"path":"2020/01/14/alg-01/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-01/","excerpt":"","text":"复杂度分析分为时间复杂度分析和空间复杂度分析，时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 什么是复杂度分析？ 数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。 为什么使用复杂度分析？ 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。 如何进行复杂度分析？ 大O表示法 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。 空间复杂度分析比时间复杂度分析要简单很多，我们常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 复杂度分析法则 单段代码看高频：比如循环。 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。 嵌套代码求乘积：比如递归、多重循环等 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 常用的复杂度级别多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶） 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶） 复杂度分析的4个概念 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 为什么要引入这4个概念？ 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 如何分析平均、均摊时间复杂度？ 平均时间复杂度 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。 均摊时间复杂度 两个条件满足时使用： 代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度； 低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://astrapub.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}]},{"title":"00. 数据结构与算法入门 | 开篇，如何学习","slug":"alg-00","date":"2020-01-14T14:49:00.000Z","updated":"2020-02-25T12:04:43.151Z","comments":true,"path":"2020/01/14/alg-00/","link":"","permalink":"http://astrapub.github.io/2020/01/14/alg-00/","excerpt":"","text":"什么是数据结构，什么是算法大部分教材里开篇都会有相关的定义，但是这些定义都很抽象，而且对于我们理解没有什么实质性帮助，所以我们不必死扣定义。那么来讲讲我的理解，数据结构就是指一组数据的存储结构，算法就是操作数据的一组方法。 可以以图书馆为例，为了方便查找，图书管理员把图书会按照一定规律放到书架上，这就是书籍这种“数据”的存储结构，而怎么才能查到一本书的具体位置，方法有很多，可以一本一本的找，也可以将图书分类然后再查找，这个查找的方法就是算法。 所以，数据结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。 学习数据结构与算法的重要性 直接好处是能够有写出性能更优的代码。 算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面。 长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。 知识体系 学习技巧数据结构与算法学习，其实是一个很枯燥的过程，很容易就坚持不下来，其实可以使用学习技巧来提升学习体验： 边学边练，适度刷题； 多问、多思考、多互动，最好能和志同道合的朋友一起学习； 给自己设立一个切实可行的目标，就像打怪升级，坚持下来； 反复迭代、温故知新，不断沉淀。 学习的方法论首先我认为学习分两点，第一，知识点的学习，主要是记忆和理解，相对简单，有清晰的目标，有良好的正反馈，学会了就是会了，可以拿来炫耀。比如，我可以告诉你帆船是通过走之字型逆风航行的，相信你很容易就能明白并记住这个知识点，但是你就能因此学会了如何驾驶帆船么，并不能，那么久引出了下面的内容；第二，技能的学习，这就需要刻意练习，不断纠正自己的错误，标准不清晰也就不容易量化，不容易形成正反馈，也就容易放弃。最典型的就是学习英语，需要反复练习，编程亦然，需要练习。 所以我总结以下几点关于学习的方法，希望和大家一起交流： 首先提高知识的广度，建立知识体系，再去拓展知识的深度； 制定切实可行的目标，一步一步来； 建立正反馈系统，可以跟牛人学，也可以和朋友一起学，对于错误能及时发现、及时纠正； 持续输出，可以写学习笔记、总结，也可以是代码和注释，如果能教会别人效果更佳； 坚持学习和健身，健身能够增加多巴胺的分泌，能使人身心愉悦，同时能提升延迟满足的能力，提高学习效率。","categories":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://astrapub.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数组","slug":"数组","permalink":"http://astrapub.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"http://astrapub.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://astrapub.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://astrapub.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"Promise、Async/Await 备忘","slug":"js-promise","date":"2020-01-06T07:17:56.000Z","updated":"2020-01-07T06:19:55.568Z","comments":true,"path":"2020/01/06/js-promise/","link":"","permalink":"http://astrapub.github.io/2020/01/06/js-promise/","excerpt":"","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise 可以理解为一个容器，保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 有all、reject、resolve 这几个方法，原型上有then、catch等方法。 有以下特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 setTimeout、Promise、Async/Await 的区别其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行； promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。 也就是说执行顺序是：任务栈（包括await后面的表达式）&gt; 微任务队列（promise.then回调，await下面的表达式）&gt; 宏任务队列（setTimeout回调）。 多个异步任务Promise 还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用 Promise 需要写一层一层的嵌套代码。有了 Promise，我们只需要简单地写： 1job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是 Promise 对象。 参考https://www.jianshu.com/p/7c6e4d21bf77https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7async/await 执行顺序详解Promise原理与实现ES6 入门之 Promise 对象","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://astrapub.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://astrapub.github.io/tags/js/"},{"name":"Promise","slug":"Promise","permalink":"http://astrapub.github.io/tags/Promise/"}]},{"title":"深刻理解 Javascript 的 this 指向","slug":"js-this","date":"2020-01-05T14:52:35.000Z","updated":"2020-01-06T03:18:18.977Z","comments":true,"path":"2020/01/05/js-this/","link":"","permalink":"http://astrapub.github.io/2020/01/05/js-this/","excerpt":"","text":"现象首先我们来看一段代码 1234567891011let a = 2;let obj = &#123; a: 1, foo: function () &#123; console.log(this.a) &#125;&#125;;let foo = obj.foo;// 写法一obj.foo()// 写法二foo() 写法一和写法二的执行结果分别是：1、2。之所以运行结果不用，是因为方法中使用了 this 关键字。this 指代方法调用者，即运行时的环境。对于obj.foo()，foo 运行在 obj 中，所以 this 指向 obj。而 foo()，foo 运行在全局，所以 this 指向全局。由此得出结论： 普通函数的 this 总是指向它的直接调用者。 在严格模式下，没找到直接调用者，则函数中的 this 是 undefined。 在默认模式下（非严格模式），没找到直接调用者，则函数中的 this 指向 window。 this 的由来JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 内存数据结果1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。Javascript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 12345678&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125; 注意，foo属性的值保存在属性描述对象的value属性里面。 函数这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 123456&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125; 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() 环境变量Javascript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量x。该变量由运行环境提供。现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的this.x就是指当前运行环境的x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x指向全局环境的x。在obj环境执行，this.x指向obj.x。回到本文开头提出的问题，obj.foo()是通过obj找到foo，所以就是在obj环境执行。一旦var foo = obj.foo，变量foo就直接指向函数本身，所以foo()就变成在全局环境执行。 箭头函数在 ES6 中新增的箭头函数，不仅简化了代码，还解决 this 飘忽不定的指向问题。 12345678var obj = &#123; a : 1, foo : function()&#123; setTimeout( function()&#123;console.log(this.a),3000&#125;) &#125;&#125;obj.foo(); //undefined 此代码运行结果为 undefined，this 的指向是全局的 window 对象。 1()=&gt;&#123;console.log(this)&#125; 其中()内是要带入的参数，{}内是要执行的语句。箭头函数是函数式编程的一种体现，函数式编程将更多的关注点放在输入和输出的关系，省去了过程的一些因素，因此箭头函数中没有自己的 this，arguments，new target（ES6）和 super(ES6)。箭头函数相当于匿名函数，因此不能使用new来作为构造函数使用。箭头函数中的 this 始终指向其父级作用域中的 this 。换句话说，箭头函数会捕获其所在的上下文的 this 值，作为自己的 this 值。任何方法都改变不了其指向，如 call(), bind(), apply()。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用，它与调用时的上下文无关。我们用代码来解释一下。 参考 阮一峰的 《JavaScript 的 this 原理》 《ES6箭头函数与普通函数的区别》","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://astrapub.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://astrapub.github.io/tags/js/"},{"name":"this","slug":"this","permalink":"http://astrapub.github.io/tags/this/"},{"name":"箭头函数","slug":"箭头函数","permalink":"http://astrapub.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}]},{"title":"2019回顾，2020展望","slug":"review2019","date":"2020-01-04T14:12:17.000Z","updated":"2020-01-05T12:41:49.679Z","comments":true,"path":"2020/01/04/review2019/","link":"","permalink":"http://astrapub.github.io/2020/01/04/review2019/","excerpt":"","text":"进入 2020 年已经4个日子了，每次跨年觉得应该有仪式感。当跨年的那一刻，2019像电影一样在脑海过了一遍，不禁要问2019都干了什么。从毕业到现在从事开发工作已经整整5个年头，有感动也有遗憾，5年的时间想想如果能坚持做一件事想想现在应该也小有成就了。 2019其实是寻找的一年，寻找自己，寻找答案。我不知道答案是否找到了，但确实明白了一些事，不再幻想，不再漫不经心，不再天马星空。越来越明白踏实做事的重要性，不再轻易被情绪控制，不卑不亢。明白世界运行的规律，独立思考，不被洗脑。 2019也是不破不立的一年，这一年经历了很多，跌宕起伏。值得庆幸的是这一年我跳出了自己的舒适圈，直面自己的弱点，虽然过程会有痛苦，但成长的喜悦难以言表，有些困难过去了就真的过去了。 目标重要，如何实现目标更重要，还是要有计划，有些看似困难的问题，其实都是有解的，掌握方式方法，刻意去练习，进步会很快。 2020，持续做好要做的事，丰富自己的知识体系，建立个人品牌，将博客继续写下去，持续写作，如果条件允许出系列教程。 review 系列也要继续写下去。","categories":[{"name":"回顾","slug":"回顾","permalink":"http://astrapub.github.io/categories/%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"回顾","slug":"回顾","permalink":"http://astrapub.github.io/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"总结","slug":"总结","permalink":"http://astrapub.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"2019","slug":"2019","permalink":"http://astrapub.github.io/tags/2019/"}]},{"title":"Hexo 使用教程","slug":"hexo-course","date":"2020-01-03T09:16:49.000Z","updated":"2020-01-04T08:18:57.647Z","comments":true,"path":"2020/01/03/hexo-course/","link":"","permalink":"http://astrapub.github.io/2020/01/03/hexo-course/","excerpt":"","text":"安装首先需要安装 node.js，node.js 安装教程可参看 https://www.runoob.com/nodejs/nodejs-install-setup.html然后执行npm install -g hexo 或 yarn global add hexo 安装 Hexo。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm i 或 yarn install 目录结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 在执行 hexo init 的时候可能git会报错，可以到 https://github.com/hexojs/hexo-starter.git 这个地址直接把 Hexo 项目下载下来，然后改成自己项目名字。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 scaffold/post.md 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。 _config.yml网站的配置信息，可以配置网站名称、关键字、语言、作者、时区等信息。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题文件夹。可以去 https://hexo.io/themes/ 寻找喜欢的主题。 安装主题我使用的主题是 pure 启用主题在你的 hexo 项目文件夹下执行： 1git clone https:&#x2F;&#x2F;github.com&#x2F;cofess&#x2F;hexo-theme-pure.git themes&#x2F;pure 修改配置文件 hexo/_config.yml 中 theme 为 pure。 gitalk 评论Gitalk 是一个基于 Github Issue 的评论插件，每增加一条评论相应的在 GitHub 项目增加一条 Issue。 注册 GitHub Application到 https://github.com/settings/applications/new 注册 GitHub Application填写 Application name（项目名称），Homepage URL（博客链接），Application description（描述），authorization callback URL（回调地址，博客链接）等信息，完成注册，获取到 Client ID 和 Client Secret。如果项目在 Organization 下，需要进入到相应的 Organization，点击 Settings &gt; OAuth Apps，注册 GitHub Application。 配置 _config.yml配置文件位置 themes/pure/_config.yml。修改 comment &gt; type 为：gitalk，将 Client ID 和 Client Secret 填写的相应位置，并填写 owner，admin，repo。owner 为项目所有者，如果是 Organization，这填写 Organization 名称。admin 为你的用户名，repo 对应 GitHub 中的项目名。 常用命令创建一个新网站1hexo init [folder] 新建一篇文章1$ hexo new [layout] &lt;title&gt; layout 可选，如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。如： 1$ hexo new &quot;post title with whitespace&quot; 参数 描述 -p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about&#x2F;me &quot;About me&quot; 生成静态文件1$ hexo generate 或 g 参数 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 示例检测文件变动实时预览： 1$ hexo g -w 生成文件自动部署： 1$ hexo g -d 启动服务器1$ hexo server 或 s 默认情况下，访问网址为： http://localhost:4000/。 部署1$ hexo deploy 部署方式请看 https://hexo.io/zh-cn/docs/one-command-deployment 清除缓存文件1$ hexo clean","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://astrapub.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://astrapub.github.io/tags/Hexo/"}]},{"title":"Docker 搭建以太坊私有链","slug":"eth-docker","date":"2018-05-18T02:21:03.000Z","updated":"2020-02-25T12:20:25.332Z","comments":true,"path":"2018/05/18/eth-docker/","link":"","permalink":"http://astrapub.github.io/2018/05/18/eth-docker/","excerpt":"","text":"Docker 搭建以太坊私有链首先需要安装 Docker，Docker 的安装和使用可以参看阮一峰老师的《Docker 入门教程》。Ethereum 官方是支持 docker 的，可以参看官方文档。 1.前期准备centOS 创建目录 ~/works/block-chain/ethereum 在 ethereum 目录下编写 start-ethereum.sh 文件内容如下1234567docker stop ethereum-nodedocker rm ethereum-nodedocker run -d --name ethereum-node -v /home/linshan/works/block-chain/ethereum:/root \\ -p 8545:8545 -p 30303:30303 -p 8200:8200\\ ethereum/client-godocker exec -it ethereum-node /bin/sh 其中 -v /home/linshan/works/block-chain/ethereum:/root 是把我们当前的 ethereum 目录，挂到了docker 的 /root 下。在 Windows 环境下使用 -v /home/linshan/works/block-chain/ethereum:/root 不能启动容器，原因不明，所以在 Windows 下先不要使用目录挂载。 接下来创建创世区块在 ethereum 目录下编写 genesis.json 文件内容如下1234567891011121314151617&#123;\"config\": &#123; \"chainId\": 622 , \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"200\", \"extraData\" : \"\", \"gasLimit\" : \"0xffffffff\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\", \"alloc\": &#123; &#125;&#125; 各字段具体用途参看官方文档。 WindowsWindows 不必创建 start-ethereum.sh 文件， genesis.json 也可以在 Docker 容器启动后创建。 2.启动以太坊 Docker 容器centOS 123456789$ sudo ./start-ethereum.shError response from daemon: No such container: ethereum-node5ef5cf1eebe96a0b6f8bc777dc69442d302aed1b086c723fb11360459347cf15/ #/ # lsbin dev etc home lib media mnt proc root run sbin srv sys tmp usr var/ # cd /root/~ # lsgenesis.json Windows 1docker run -d --name ethereum-node -p 8545:8545 -p 30303:30303 -p 8200:8200 ethereum&#x2F;client-go 运行成功后执行 1docker exec -it ethereum-node &#x2F;bin&#x2F;sh 进入 docker 容器命令行因为 Windows 没有挂载共享目录，所以 root 目录下没有 genesis.json 文件，我们要在这里手动创建 genesis.json 文件，内容要和 centOS 的一致。 3.初始化 geth1~ # geth --datadir ./data init ./genesis.json data 用来存放区块数据 4.启动私有链1~ # geth --datadir ./data --networkid 622 --port 8200 --rpc --rpcaddr 0.0.0.0 --rpccorsdomain \"*\" --rpcport 8545 --nodiscover console geth 的参数参看以太坊客户端Geth命令用法-参数详解 5.连接节点启动私有节点后进入 geth 命令行执行： 12&gt; admin.nodeInfo.enode&quot;enode:&#x2F;&#x2F;a1ae9aef2b0575875fc366cf9057e6fe7182068c2f6570859315400b32b7b341bd90e1b65fd59291800f4d6196640420fba52f79ceaff793a3cff51b49281634@[::]:8200?discport&#x3D;0&quot; 输出的内容就是节点信息，我们在手动连接节点是会用到，注意要把“0.0.0.0“换成你自己的IP，然后将这个信息发送给其他节点。手动连接节点有两种方式： 在节点启动时连接：1geth --datadir .&#x2F;data --networkid 622 --ipcdisable --port 8200 --rpc --rpcaddr 0.0.0.0 --rpccorsdomain &quot;*&quot; --rpcport 8545 --bootnodes &quot;enode:&#x2F;&#x2F;a1ae9aef2b0575875fc366cf9057e6fe7182068c2f6570859315400b32b7b341bd90e1b65fd59291800f4d6196640420fba52f79ceaff793a3cff51b49281634@[::]:8200&quot; --nodiscover console 使用 admin.addPeer 连接如果节点已经启动可以使用该方法。1admin.addPeer(&quot;enode:&#x2F;&#x2F;a1ae9aef2b0575875fc366cf9057e6fe7182068c2f6570859315400b32b7b341bd90e1b65fd59291800f4d6196640420fba52f79ceaff793a3cff51b49281634@[::]:8200&quot;) 当然不管使用哪种方法连接节点都要保证创世区块文件 genesis.json 一致，还有在启动时 networkid 也要一致。 至此以太坊私有链已搭建完毕。 6.geth docker 常用命令geth命令 geth –rpc –rpcaddr 0.0.0.0 –rpccorsdomain “*” –datadir ./data –networkid 622 console 启动节点（https://www.cnblogs.com/tinyxiong/p/7918706.html） geth –datadir “~/ethdev” –dev 以开发方式启动geth （https://blog.csdn.net/CHENYUFENG1991/article/details/53458175?locationNum=7&amp;fps=1） geth –dev console 2&gt;&gt;file_to_log_output 进入geth控制台 personal.newAccount() 创建账户 eth.accounts 查看账户 eth.getBalance(eth.accounts[0]) 查看账户余额 miner.setEtherbase(eth.accounts[0]) 设置挖矿地址 miner.start() 启动挖矿 miner.stop() 停止挖矿 admin.nodeInfo 节点信息 eth.blockNumber 查看区块数 exit 退出geth控制台 personal.unlockAccount(acc0) 解锁账号 eth.sendTransaction({from:acc0,to:acc1,value:web3.toWei(20,”ether”)}) 转账 docker命令 exit 交互型容器退出（https://blog.csdn.net/u010246789/article/details/53958662） docker create 创建容器 docker start 启动容器 docker ps 查看当前运行的容器 docker ps -a 查看所有容器，包括停止的。 docker stop [NAME]/[CONTAINER ID] 将容器退出。 docker kill [NAME]/[CONTAINER ID] 强制停止一个容器。 docker rm [NAME]/[CONTAINER ID] 删除容器，不能够删除一个正在运行的容器，会报错。需要先停止容器。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://astrapub.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://astrapub.github.io/tags/Docker/"},{"name":"区块链","slug":"区块链","permalink":"http://astrapub.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"以太坊","permalink":"http://astrapub.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"接入以太坊（Ethereum）测试网络","slug":"eth-test","date":"2018-03-30T11:01:31.000Z","updated":"2020-02-25T12:20:56.156Z","comments":true,"path":"2018/03/30/eth-test/","link":"","permalink":"http://astrapub.github.io/2018/03/30/eth-test/","excerpt":"","text":"什么是测试网络以太坊为了方便智能合约的开发、学习和测试，开启了一条全新的区块链，与主网络特性相同，但测试网络中的以太币价值更低，也更容易得到。这样不至于在主网络上开发出现 BUG 造成以太币的损失。 当然我们也可以搭建私有的测试网络，不过区块链的去中心化特点，需要更多的节点运行才能达到理想效果，好在以太坊有公开的测试网络，而我们接入也更容易。 以太坊测试网络 Ropsten Ropsten也是以太坊官方提供的测试网络，是为了解决Morden难度炸弹问题而重新启动的一条区块链，目前仍在运行，共识机制为PoW。测试网络上的以太币并无实际价值，因此Ropsten的挖矿难度很低，目前在755M左右，仅仅只有主网络的0.07%。这样低的难度一方面使一台普通笔记本电脑的CPU也可以挖出区块，获得测试网络上的以太币，方便开发人员测试软件，但是却不能阻止攻击。 PoW共识机制要求有足够强大的算力保证没有人可以随意生成区块，这种共识机制只有在具有实际价值的主网络中才会有效。测试网络上的以太币没有价值，也就不会有强大的算力投入来维护测试网络的安全，这就导致了测试网络的挖矿难度很低，即使几块普通的显卡，也足以进行一次51%攻击，或者用垃圾交易阻塞区块链，攻击的成本及其低廉。 2017年2月，Ropsten便遭到了一次利用测试网络的低难度进行的攻击，攻击者发送了千万级的垃圾交易，并逐渐把区块Gas上限从正常的4,700,000提高到了90,000,000,000，在一段时间内，影响了测试网络的运行。攻击者发动这些攻击，并不能获得利益，仅仅是为了测试、炫耀、或者单纯觉得好玩儿。 Rinkeby Rinkeby也是以太坊官方提供的测试网络，使用PoA共识机制。与Ropsten不同，以太坊团队提供了Rinkeby的PoA共识机制说明文档，理论上任何以太坊钱包都可以根据这个说明文档，支持Rinkeby测试网络，目前Rinkeby已经开始运行。 安装以太钱包下载地址：https://github.com/ethereum/mist/releases ) 目前最新的版本是0.10.0，根据操作系统下载相应版本。 MIST其实只是以太坊钱包的一个图形界面，后端还是官方的Geth，只是可以使用图形化的方式操作，减少了出错的几率，降低使用门槛。MIST是使用Electron开发的，具有跨平台的能力，所以在各个系统上的界面和操作应该是基本一致的。 第一次启动 ) 稍等一会会出现 LAUNCH APPLICATION 按钮，点击启动钱包。 切换到 Ropsten 网络 启动后点击菜单栏 “开发”&gt;“网络” 选择“Ropsten - Test network” ) 然后点击菜单栏 “账户”&gt;“新建账户”然后输入密码创建账户 ) 然后可以开启挖矿，用不了多久就可以获得 Ropsten 网络的以太币。 ) 切换到 Rinkeby 网络 同 Ropsten 选择 “Rinkeby - Test network” ) 切换完网络后同样需要创建账户。 获取 Rinkeby 网络的以太币Rinkeby测试网络使用的是PoA共识机制，我们不能通过挖矿来获取以太币。 想获取Rinkeby测试网络中的以太币，需要去申请，这个申请Rinkeby以太币的功能被称为水龙头(Faucet)。还真是挺形象的，水龙头会源源不断的产生以太币，并且受到权威节点控制，以确保不会被滥用。 进入这个水龙头的网站：Rinkeby: GitHub Faucet ) 为了确保不会出现有人滥用水龙头，无限生成Rinkeby以太币，水龙头需要借助社交账号来确定申请者的身份和配额。目前支持 twitter , Google Plus , Facebook，取消了 Github 账户。不过最先测试了 Facebook 没有成功，可能是打开方式不对，如果有成功的小伙伴记得告诉我啊。然后是 twitter 亲测可用。 打开 [twitter](https://twitter.com/intent/tweet?text=Requesting faucet funds into 0x0000000000000000000000000000000000000000 on the %23Rinkeby %23Ethereum test network.)，然后把钱包账户的地址粘贴进去，然后点击 “Tweet”。 ) 然后进入 twitter 首页，找到你发的 twitter 点击右上角的小箭头，选择“Copy link to Tweet”。 ) 然后回到水龙头的网站，将拷贝的链接粘贴到输入框，点击 “Give me Ether”有三种选项，前面是获得的以太币数量，后面是冷却时间，在冷却时间过后才能进行下一次以太币申请。 ) 如果一切顺利，你会看到你的钱包地址已经多出了申请数量的以太币，我申请了两次，在钱包中还看不到余额，不过在区块浏览器中可以看到 0x53Ac8771A2f7C8730D94Bea19466F05C19aFbE22。 ) 如果申请的人数很多，需要排队等待一会儿，申请的以太币金额越大，一般需要等待越多的时间才能到账。 为什么申请测试网络的以太币如此繁琐呢？ 以太币在以太坊平台中的设计功能是用来支付EVM中执行指令消耗的Gas，如果可以被无限制的产生，就会出现有恶意用户出于各种目的，用无限制的以太币换无限制的Gas，在EVM中执行超多的指令，并逐渐抬高区块Gas上限。EVM中的指令要在每一个以太坊节点中执行，这种攻击一旦出现，对网络将会产生很大的影响，所以测试网络中的以太币必须针对每个开发者限量供应。不过这个限量对正常的开发测试来说，几乎不会造成影响。 如果你看到了这里，并且成功的在自己的电脑上运行了钱包、连接测试网络、申请以太币，那么恭喜你，你已经做好了进一步学习和了解以太坊的准备。 参考：玩转以太坊(Ethereum)的测试网络","categories":[{"name":"区块链","slug":"区块链","permalink":"http://astrapub.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://astrapub.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"以太坊","permalink":"http://astrapub.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"Ropsten","slug":"Ropsten","permalink":"http://astrapub.github.io/tags/Ropsten/"}]}]}